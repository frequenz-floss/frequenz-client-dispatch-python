{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Dispatch Client Library","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Dispatch API client for Python</p>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<p>The following platforms are officially supported (tested):</p> <ul> <li>Python: 3.11</li> <li>Operating System: Ubuntu Linux 20.04</li> <li>Architectures: amd64, arm64</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz Dispatch Client Library","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>client<ul> <li>dispatch<ul> <li>test<ul> <li>client</li> <li>fixtures</li> <li>generator</li> </ul> </li> <li>types</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/frequenz/client/dispatch/","title":"Index","text":""},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch","title":"frequenz.client.dispatch","text":"<p>Dispatch API client for Python.</p>"},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch-classes","title":"Classes","text":""},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch.Client","title":"frequenz.client.dispatch.Client","text":"<p>               Bases: <code>BaseApiClient[MicrogridDispatchServiceStub]</code></p> <p>Dispatch API client.</p> Source code in <code>frequenz/client/dispatch/_client.py</code> <pre><code>class Client(BaseApiClient[dispatch_pb2_grpc.MicrogridDispatchServiceStub]):\n    \"\"\"Dispatch API client.\"\"\"\n\n    streams: dict[\n        int, GrpcStreamBroadcaster[StreamMicrogridDispatchesResponse, DispatchEvent]\n    ] = {}\n    \"\"\"A dictionary of streamers, keyed by microgrid_id.\"\"\"\n\n    def __init__(\n        self,\n        *,\n        server_url: str,\n        key: str,\n        connect: bool = True,\n    ) -&gt; None:\n        \"\"\"Initialize the client.\n\n        Args:\n            server_url: The URL of the server to connect to.\n            key: API key to use for authentication.\n            connect: Whether to connect to the service immediately.\n        \"\"\"\n        super().__init__(\n            server_url,\n            dispatch_pb2_grpc.MicrogridDispatchServiceStub,\n            connect=connect,\n            channel_defaults=ChannelOptions(\n                port=DEFAULT_DISPATCH_PORT,\n                ssl=SslOptions(\n                    enabled=True,\n                    root_certificates=Path(\n                        str(\n                            files(\"frequenz.client.dispatch\").joinpath(\"certs/root.crt\")\n                        ),\n                    ),\n                ),\n            ),\n        )\n        self._metadata = ((\"key\", key),)\n\n    # pylint: disable=too-many-arguments, too-many-locals\n    async def list(\n        self,\n        microgrid_id: int,\n        *,\n        component_selectors: Iterator[ComponentSelector] = iter(()),\n        start_from: datetime | None = None,\n        start_to: datetime | None = None,\n        end_from: datetime | None = None,\n        end_to: datetime | None = None,\n        active: bool | None = None,\n        dry_run: bool | None = None,\n        page_size: int | None = None,\n    ) -&gt; AsyncIterator[Iterator[Dispatch]]:\n        \"\"\"List dispatches.\n\n        This function handles pagination internally and returns an async iterator\n        over the dispatches. Pagination parameters like `page_size` and `page_token`\n        can be used, but they are mutually exclusive.\n\n        Example usage:\n\n        ```python\n        client = Client(key=\"key\", server_url=\"grpc://fz-0004.frequenz.io\")\n        async for page in client.list(microgrid_id=1):\n            for dispatch in page:\n                print(dispatch)\n        ```\n\n        Args:\n            microgrid_id: The microgrid_id to list dispatches for.\n            component_selectors: optional, list of component ids or categories to filter by.\n            start_from: optional, filter by start_time &gt;= start_from.\n            start_to: optional, filter by start_time &lt; start_to.\n            end_from: optional, filter by end_time &gt;= end_from.\n            end_to: optional, filter by end_time &lt; end_to.\n            active: optional, filter by active status.\n            dry_run: optional, filter by dry_run status.\n            page_size: optional, number of dispatches to return per page.\n\n        Returns:\n            An async iterator over pages of dispatches.\n\n        Yields:\n            A page of dispatches over which you can lazily iterate.\n        \"\"\"\n\n        def to_interval(\n            from_: datetime | None, to: datetime | None\n        ) -&gt; PBTimeIntervalFilter | None:\n            return (\n                PBTimeIntervalFilter(\n                    **{\"from\": to_timestamp(from_)}, to=to_timestamp(to)\n                )\n                if from_ or to\n                else None\n            )\n\n        # Setup parameters\n        start_time_interval = to_interval(start_from, start_to)\n        end_time_interval = to_interval(end_from, end_to)\n        selectors = list(map(component_selector_to_protobuf, component_selectors))\n        filters = DispatchFilter(\n            selectors=selectors,\n            start_time_interval=start_time_interval,\n            end_time_interval=end_time_interval,\n            is_active=active,\n            is_dry_run=dry_run,\n        )\n\n        request = ListMicrogridDispatchesRequest(\n            microgrid_id=microgrid_id,\n            filter=filters,\n            pagination_params=(\n                PaginationParams(page_size=page_size) if page_size else None\n            ),\n        )\n\n        while True:\n            response = await cast(\n                Awaitable[ListMicrogridDispatchesResponse],\n                self.stub.ListMicrogridDispatches(request, metadata=self._metadata),\n            )\n\n            yield (Dispatch.from_protobuf(dispatch) for dispatch in response.dispatches)\n\n            if len(response.pagination_info.next_page_token):\n                request.pagination_params.CopyFrom(\n                    PaginationParams(\n                        page_token=response.pagination_info.next_page_token\n                    )\n                )\n            else:\n                break\n\n    def stream(self, microgrid_id: int) -&gt; channels.Receiver[DispatchEvent]:\n        \"\"\"Receive a stream of dispatch events.\n\n        This function returns a receiver channel that can be used to receive\n        dispatch events.\n        An event is one of [CREATE, UPDATE, DELETE].\n\n        Example usage:\n\n        ```\n        client = Client(key=\"key\", server_url=\"grpc://fz-0004.frequenz.io\")\n        async for message in client.stream(microgrid_id=1):\n            print(message.event, message.dispatch)\n        ```\n\n        Args:\n            microgrid_id: The microgrid_id to receive dispatches for.\n\n        Returns:\n            A receiver channel to receive the stream of dispatch events.\n        \"\"\"\n        return self._get_stream(microgrid_id).new_receiver()\n\n    def _get_stream(\n        self, microgrid_id: int\n    ) -&gt; GrpcStreamBroadcaster[StreamMicrogridDispatchesResponse, DispatchEvent]:\n        \"\"\"Get an instance to the streaming helper.\"\"\"\n        broadcaster = self.streams.get(microgrid_id)\n        # pylint: disable=protected-access\n        if broadcaster is not None and broadcaster._channel.is_closed:\n            # pylint: enable=protected-access\n            del self.streams[microgrid_id]\n            broadcaster = None\n        if broadcaster is None:\n            request = StreamMicrogridDispatchesRequest(microgrid_id=microgrid_id)\n            broadcaster = GrpcStreamBroadcaster(\n                stream_name=\"StreamMicrogridDispatches\",\n                stream_method=lambda: cast(\n                    AsyncIterator[StreamMicrogridDispatchesResponse],\n                    self.stub.StreamMicrogridDispatches(\n                        request, metadata=self._metadata\n                    ),\n                ),\n                transform=DispatchEvent.from_protobuf,\n                retry_strategy=LinearBackoff(interval=1, limit=0),\n            )\n            self.streams[microgrid_id] = broadcaster\n\n        return broadcaster\n\n    async def create(  # pylint: disable=too-many-positional-arguments\n        self,\n        microgrid_id: int,\n        type: str,  # pylint: disable=redefined-builtin\n        start_time: datetime,\n        duration: timedelta | None,\n        selector: ComponentSelector,\n        *,\n        active: bool = True,\n        dry_run: bool = False,\n        payload: dict[str, Any] | None = None,\n        recurrence: RecurrenceRule | None = None,\n    ) -&gt; Dispatch:\n        \"\"\"Create a dispatch.\n\n        Will try to return the created dispatch, identifying it by\n        the same fields as the request.\n\n        Args:\n            microgrid_id: The microgrid_id to create the dispatch for.\n            type: User defined string to identify the dispatch type.\n            start_time: The start time of the dispatch.\n            duration: The duration of the dispatch. Can be `None` for infinite\n                or no-duration dispatches (e.g. switching a component on).\n            selector: The component selector for the dispatch.\n            active: The active status of the dispatch.\n            dry_run: The dry_run status of the dispatch.\n            payload: The payload of the dispatch.\n            recurrence: The recurrence rule of the dispatch.\n\n        Returns:\n            Dispatch: The created dispatch\n\n        Raises:\n            ValueError: If start_time is in the past.\n        \"\"\"\n        if start_time &lt;= datetime.now(tz=start_time.tzinfo):\n            raise ValueError(\"start_time must not be in the past\")\n\n        # Raise if it's not UTC\n        if start_time.tzinfo is None or start_time.tzinfo.utcoffset(start_time) is None:\n            raise ValueError(\"start_time must be timezone aware\")\n\n        request = DispatchCreateRequest(\n            microgrid_id=microgrid_id,\n            type=type,\n            start_time=start_time,\n            duration=duration,\n            selector=selector,\n            active=active,\n            dry_run=dry_run,\n            payload=payload or {},\n            recurrence=recurrence,\n        )\n\n        response = await cast(\n            Awaitable[CreateMicrogridDispatchResponse],\n            self.stub.CreateMicrogridDispatch(\n                request.to_protobuf(), metadata=self._metadata\n            ),\n        )\n\n        return Dispatch.from_protobuf(response.dispatch)\n\n    async def update(\n        self,\n        *,\n        microgrid_id: int,\n        dispatch_id: int,\n        new_fields: dict[str, Any],\n    ) -&gt; Dispatch:\n        \"\"\"Update a dispatch.\n\n        The `new_fields` argument is a dictionary of fields to update. The keys are\n        the field names, and the values are the new values for the fields.\n\n        For recurrence fields, the keys are preceeded by \"recurrence.\".\n\n        Note that updating `type` and `dry_run` is not supported.\n\n        Args:\n            microgrid_id: The microgrid_id to update the dispatch for.\n            dispatch_id: The dispatch_id to update.\n            new_fields: The fields to update.\n\n        Returns:\n            Dispatch: The updated dispatch.\n\n        Raises:\n            ValueError: If updating `type` or `dry_run`.\n        \"\"\"\n        msg = UpdateMicrogridDispatchRequest(\n            dispatch_id=dispatch_id, microgrid_id=microgrid_id\n        )\n\n        for key, val in new_fields.items():\n            path = key.split(\".\")\n\n            match path[0]:\n                case \"start_time\":\n                    msg.update.start_time.CopyFrom(to_timestamp(val))\n                case \"duration\":\n                    if val is None:\n                        msg.update.ClearField(\"duration\")\n                    else:\n                        msg.update.duration = round(val.total_seconds())\n                case \"selector\":\n                    msg.update.selector.CopyFrom(component_selector_to_protobuf(val))\n                case \"is_active\":\n                    msg.update.is_active = val\n                case \"payload\":\n                    msg.update.payload.update(val)\n                case \"active\":\n                    msg.update.is_active = val\n                    key = \"is_active\"\n                case \"recurrence\":\n                    match path[1]:\n                        case \"freq\":\n                            msg.update.recurrence.freq = val\n                        # Proto uses \"freq\" instead of \"frequency\"\n                        case \"frequency\":\n                            msg.update.recurrence.freq = val\n                            # Correct the key to \"recurrence.freq\"\n                            key = \"recurrence.freq\"\n                        case \"interval\":\n                            msg.update.recurrence.interval = val\n                        case \"end_criteria\":\n                            msg.update.recurrence.end_criteria.CopyFrom(\n                                val.to_protobuf()\n                            )\n                        case \"byminutes\":\n                            msg.update.recurrence.byminutes.extend(val)\n                        case \"byhours\":\n                            msg.update.recurrence.byhours.extend(val)\n                        case \"byweekdays\":\n                            msg.update.recurrence.byweekdays.extend(val)\n                        case \"bymonthdays\":\n                            msg.update.recurrence.bymonthdays.extend(val)\n                        case \"bymonths\":\n                            msg.update.recurrence.bymonths.extend(val)\n                        case _:\n                            raise ValueError(f\"Unknown recurrence field: {path[1]}\")\n                case _:\n                    raise ValueError(f\"Unknown field: {path[0]}\")\n\n            msg.update_mask.paths.append(key)\n\n        response = await cast(\n            Awaitable[UpdateMicrogridDispatchResponse],\n            self.stub.UpdateMicrogridDispatch(msg, metadata=self._metadata),\n        )\n\n        return Dispatch.from_protobuf(response.dispatch)\n\n    async def get(self, *, microgrid_id: int, dispatch_id: int) -&gt; Dispatch:\n        \"\"\"Get a dispatch.\n\n        Args:\n            microgrid_id: The microgrid_id to get the dispatch for.\n            dispatch_id: The dispatch_id to get.\n\n        Returns:\n            Dispatch: The dispatch.\n        \"\"\"\n        request = GetMicrogridDispatchRequest(\n            dispatch_id=dispatch_id, microgrid_id=microgrid_id\n        )\n        response = await cast(\n            Awaitable[GetMicrogridDispatchResponse],\n            self.stub.GetMicrogridDispatch(request, metadata=self._metadata),\n        )\n        return Dispatch.from_protobuf(response.dispatch)\n\n    async def delete(self, *, microgrid_id: int, dispatch_id: int) -&gt; None:\n        \"\"\"Delete a dispatch.\n\n        Args:\n            microgrid_id: The microgrid_id to delete the dispatch for.\n            dispatch_id: The dispatch_id to delete.\n        \"\"\"\n        request = DeleteMicrogridDispatchRequest(\n            dispatch_id=dispatch_id, microgrid_id=microgrid_id\n        )\n        await cast(\n            Awaitable[None],\n            self.stub.DeleteMicrogridDispatch(request, metadata=self._metadata),\n        )\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch.Client-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch.Client.channel","title":"channel  <code>property</code>","text":"<pre><code>channel: Channel\n</code></pre> <p>The underlying gRPC channel used to communicate with the server.</p> Warning <p>This channel is provided as a last resort for advanced users. It is not recommended to use this property directly unless you know what you are doing and you don't care about being tied to a specific gRPC library.</p> RAISES DESCRIPTION <code>ClientNotConnected</code> <p>If the client is not connected to the server.</p>"},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch.Client.channel_defaults","title":"channel_defaults  <code>property</code>","text":"<pre><code>channel_defaults: ChannelOptions\n</code></pre> <p>The default options for the gRPC channel.</p>"},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch.Client.is_connected","title":"is_connected  <code>property</code>","text":"<pre><code>is_connected: bool\n</code></pre> <p>Whether the client is connected to the server.</p>"},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch.Client.server_url","title":"server_url  <code>property</code>","text":"<pre><code>server_url: str\n</code></pre> <p>The URL of the server.</p>"},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch.Client.streams","title":"streams  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>streams: dict[\n    int,\n    GrpcStreamBroadcaster[\n        StreamMicrogridDispatchesResponse, DispatchEvent\n    ],\n] = {}\n</code></pre> <p>A dictionary of streamers, keyed by microgrid_id.</p>"},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch.Client.stub","title":"stub  <code>property</code>","text":"<pre><code>stub: StubT\n</code></pre> <p>The underlying gRPC stub.</p> Warning <p>This stub is provided as a last resort for advanced users. It is not recommended to use this property directly unless you know what you are doing and you don't care about being tied to a specific gRPC library.</p> RAISES DESCRIPTION <code>ClientNotConnected</code> <p>If the client is not connected to the server.</p>"},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch.Client-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch.Client.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter a context manager.</p> Source code in <code>frequenz/client/base/client.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enter a context manager.\"\"\"\n    self.connect()\n    return self\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch.Client.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    _exc_type: type[BaseException] | None,\n    _exc_val: BaseException | None,\n    _exc_tb: Any | None,\n) -&gt; bool | None\n</code></pre> <p>Exit a context manager.</p> Source code in <code>frequenz/client/base/client.py</code> <pre><code>async def __aexit__(\n    self,\n    _exc_type: type[BaseException] | None,\n    _exc_val: BaseException | None,\n    _exc_tb: Any | None,\n) -&gt; bool | None:\n    \"\"\"Exit a context manager.\"\"\"\n    if self._channel is None:\n        return None\n    result = await self._channel.__aexit__(_exc_type, _exc_val, _exc_tb)\n    self._channel = None\n    self._stub = None\n    return result\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch.Client.__init__","title":"__init__","text":"<pre><code>__init__(\n    *, server_url: str, key: str, connect: bool = True\n) -&gt; None\n</code></pre> <p>Initialize the client.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server to connect to.</p> <p> TYPE: <code>str</code> </p> <code>key</code> <p>API key to use for authentication.</p> <p> TYPE: <code>str</code> </p> <code>connect</code> <p>Whether to connect to the service immediately.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>frequenz/client/dispatch/_client.py</code> <pre><code>def __init__(\n    self,\n    *,\n    server_url: str,\n    key: str,\n    connect: bool = True,\n) -&gt; None:\n    \"\"\"Initialize the client.\n\n    Args:\n        server_url: The URL of the server to connect to.\n        key: API key to use for authentication.\n        connect: Whether to connect to the service immediately.\n    \"\"\"\n    super().__init__(\n        server_url,\n        dispatch_pb2_grpc.MicrogridDispatchServiceStub,\n        connect=connect,\n        channel_defaults=ChannelOptions(\n            port=DEFAULT_DISPATCH_PORT,\n            ssl=SslOptions(\n                enabled=True,\n                root_certificates=Path(\n                    str(\n                        files(\"frequenz.client.dispatch\").joinpath(\"certs/root.crt\")\n                    ),\n                ),\n            ),\n        ),\n    )\n    self._metadata = ((\"key\", key),)\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch.Client.connect","title":"connect","text":"<pre><code>connect(server_url: str | None = None) -&gt; None\n</code></pre> <p>Connect to the server, possibly using a new URL.</p> <p>If the client is already connected and the URL is the same as the previous URL, this method does nothing. If you want to force a reconnection, you can call disconnect() first.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server to connect to. If not provided, the previously used URL is used.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/client/base/client.py</code> <pre><code>def connect(self, server_url: str | None = None) -&gt; None:\n    \"\"\"Connect to the server, possibly using a new URL.\n\n    If the client is already connected and the URL is the same as the previous URL,\n    this method does nothing. If you want to force a reconnection, you can call\n    [disconnect()][frequenz.client.base.client.BaseApiClient.disconnect] first.\n\n    Args:\n        server_url: The URL of the server to connect to. If not provided, the\n            previously used URL is used.\n    \"\"\"\n    if server_url is not None and server_url != self._server_url:  # URL changed\n        self._server_url = server_url\n    elif self.is_connected:\n        return\n    self._channel = parse_grpc_uri(self._server_url, self._channel_defaults)\n    self._stub = self._create_stub(self._channel)\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch.Client.create","title":"create  <code>async</code>","text":"<pre><code>create(\n    microgrid_id: int,\n    type: str,\n    start_time: datetime,\n    duration: timedelta | None,\n    selector: ComponentSelector,\n    *,\n    active: bool = True,\n    dry_run: bool = False,\n    payload: dict[str, Any] | None = None,\n    recurrence: RecurrenceRule | None = None\n) -&gt; Dispatch\n</code></pre> <p>Create a dispatch.</p> <p>Will try to return the created dispatch, identifying it by the same fields as the request.</p> PARAMETER DESCRIPTION <code>microgrid_id</code> <p>The microgrid_id to create the dispatch for.</p> <p> TYPE: <code>int</code> </p> <code>type</code> <p>User defined string to identify the dispatch type.</p> <p> TYPE: <code>str</code> </p> <code>start_time</code> <p>The start time of the dispatch.</p> <p> TYPE: <code>datetime</code> </p> <code>duration</code> <p>The duration of the dispatch. Can be <code>None</code> for infinite or no-duration dispatches (e.g. switching a component on).</p> <p> TYPE: <code>timedelta | None</code> </p> <code>selector</code> <p>The component selector for the dispatch.</p> <p> TYPE: <code>ComponentSelector</code> </p> <code>active</code> <p>The active status of the dispatch.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>dry_run</code> <p>The dry_run status of the dispatch.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>payload</code> <p>The payload of the dispatch.</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>recurrence</code> <p>The recurrence rule of the dispatch.</p> <p> TYPE: <code>RecurrenceRule | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Dispatch</code> <p>The created dispatch</p> <p> TYPE: <code>Dispatch</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If start_time is in the past.</p> Source code in <code>frequenz/client/dispatch/_client.py</code> <pre><code>async def create(  # pylint: disable=too-many-positional-arguments\n    self,\n    microgrid_id: int,\n    type: str,  # pylint: disable=redefined-builtin\n    start_time: datetime,\n    duration: timedelta | None,\n    selector: ComponentSelector,\n    *,\n    active: bool = True,\n    dry_run: bool = False,\n    payload: dict[str, Any] | None = None,\n    recurrence: RecurrenceRule | None = None,\n) -&gt; Dispatch:\n    \"\"\"Create a dispatch.\n\n    Will try to return the created dispatch, identifying it by\n    the same fields as the request.\n\n    Args:\n        microgrid_id: The microgrid_id to create the dispatch for.\n        type: User defined string to identify the dispatch type.\n        start_time: The start time of the dispatch.\n        duration: The duration of the dispatch. Can be `None` for infinite\n            or no-duration dispatches (e.g. switching a component on).\n        selector: The component selector for the dispatch.\n        active: The active status of the dispatch.\n        dry_run: The dry_run status of the dispatch.\n        payload: The payload of the dispatch.\n        recurrence: The recurrence rule of the dispatch.\n\n    Returns:\n        Dispatch: The created dispatch\n\n    Raises:\n        ValueError: If start_time is in the past.\n    \"\"\"\n    if start_time &lt;= datetime.now(tz=start_time.tzinfo):\n        raise ValueError(\"start_time must not be in the past\")\n\n    # Raise if it's not UTC\n    if start_time.tzinfo is None or start_time.tzinfo.utcoffset(start_time) is None:\n        raise ValueError(\"start_time must be timezone aware\")\n\n    request = DispatchCreateRequest(\n        microgrid_id=microgrid_id,\n        type=type,\n        start_time=start_time,\n        duration=duration,\n        selector=selector,\n        active=active,\n        dry_run=dry_run,\n        payload=payload or {},\n        recurrence=recurrence,\n    )\n\n    response = await cast(\n        Awaitable[CreateMicrogridDispatchResponse],\n        self.stub.CreateMicrogridDispatch(\n            request.to_protobuf(), metadata=self._metadata\n        ),\n    )\n\n    return Dispatch.from_protobuf(response.dispatch)\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch.Client.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(*, microgrid_id: int, dispatch_id: int) -&gt; None\n</code></pre> <p>Delete a dispatch.</p> PARAMETER DESCRIPTION <code>microgrid_id</code> <p>The microgrid_id to delete the dispatch for.</p> <p> TYPE: <code>int</code> </p> <code>dispatch_id</code> <p>The dispatch_id to delete.</p> <p> TYPE: <code>int</code> </p> Source code in <code>frequenz/client/dispatch/_client.py</code> <pre><code>async def delete(self, *, microgrid_id: int, dispatch_id: int) -&gt; None:\n    \"\"\"Delete a dispatch.\n\n    Args:\n        microgrid_id: The microgrid_id to delete the dispatch for.\n        dispatch_id: The dispatch_id to delete.\n    \"\"\"\n    request = DeleteMicrogridDispatchRequest(\n        dispatch_id=dispatch_id, microgrid_id=microgrid_id\n    )\n    await cast(\n        Awaitable[None],\n        self.stub.DeleteMicrogridDispatch(request, metadata=self._metadata),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch.Client.disconnect","title":"disconnect  <code>async</code>","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the server.</p> <p>If the client is not connected, this method does nothing.</p> Source code in <code>frequenz/client/base/client.py</code> <pre><code>async def disconnect(self) -&gt; None:\n    \"\"\"Disconnect from the server.\n\n    If the client is not connected, this method does nothing.\n    \"\"\"\n    await self.__aexit__(None, None, None)\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch.Client.get","title":"get  <code>async</code>","text":"<pre><code>get(*, microgrid_id: int, dispatch_id: int) -&gt; Dispatch\n</code></pre> <p>Get a dispatch.</p> PARAMETER DESCRIPTION <code>microgrid_id</code> <p>The microgrid_id to get the dispatch for.</p> <p> TYPE: <code>int</code> </p> <code>dispatch_id</code> <p>The dispatch_id to get.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Dispatch</code> <p>The dispatch.</p> <p> TYPE: <code>Dispatch</code> </p> Source code in <code>frequenz/client/dispatch/_client.py</code> <pre><code>async def get(self, *, microgrid_id: int, dispatch_id: int) -&gt; Dispatch:\n    \"\"\"Get a dispatch.\n\n    Args:\n        microgrid_id: The microgrid_id to get the dispatch for.\n        dispatch_id: The dispatch_id to get.\n\n    Returns:\n        Dispatch: The dispatch.\n    \"\"\"\n    request = GetMicrogridDispatchRequest(\n        dispatch_id=dispatch_id, microgrid_id=microgrid_id\n    )\n    response = await cast(\n        Awaitable[GetMicrogridDispatchResponse],\n        self.stub.GetMicrogridDispatch(request, metadata=self._metadata),\n    )\n    return Dispatch.from_protobuf(response.dispatch)\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch.Client.list","title":"list  <code>async</code>","text":"<pre><code>list(\n    microgrid_id: int,\n    *,\n    component_selectors: Iterator[ComponentSelector] = iter(\n        ()\n    ),\n    start_from: datetime | None = None,\n    start_to: datetime | None = None,\n    end_from: datetime | None = None,\n    end_to: datetime | None = None,\n    active: bool | None = None,\n    dry_run: bool | None = None,\n    page_size: int | None = None\n) -&gt; AsyncIterator[Iterator[Dispatch]]\n</code></pre> <p>List dispatches.</p> <p>This function handles pagination internally and returns an async iterator over the dispatches. Pagination parameters like <code>page_size</code> and <code>page_token</code> can be used, but they are mutually exclusive.</p> <p>Example usage:</p> <pre><code>client = Client(key=\"key\", server_url=\"grpc://fz-0004.frequenz.io\")\nasync for page in client.list(microgrid_id=1):\n    for dispatch in page:\n        print(dispatch)\n</code></pre> PARAMETER DESCRIPTION <code>microgrid_id</code> <p>The microgrid_id to list dispatches for.</p> <p> TYPE: <code>int</code> </p> <code>component_selectors</code> <p>optional, list of component ids or categories to filter by.</p> <p> TYPE: <code>Iterator[ComponentSelector]</code> DEFAULT: <code>iter(())</code> </p> <code>start_from</code> <p>optional, filter by start_time &gt;= start_from.</p> <p> TYPE: <code>datetime | None</code> DEFAULT: <code>None</code> </p> <code>start_to</code> <p>optional, filter by start_time &lt; start_to.</p> <p> TYPE: <code>datetime | None</code> DEFAULT: <code>None</code> </p> <code>end_from</code> <p>optional, filter by end_time &gt;= end_from.</p> <p> TYPE: <code>datetime | None</code> DEFAULT: <code>None</code> </p> <code>end_to</code> <p>optional, filter by end_time &lt; end_to.</p> <p> TYPE: <code>datetime | None</code> DEFAULT: <code>None</code> </p> <code>active</code> <p>optional, filter by active status.</p> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> <code>dry_run</code> <p>optional, filter by dry_run status.</p> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> <code>page_size</code> <p>optional, number of dispatches to return per page.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>AsyncIterator[Iterator[Dispatch]]</code> <p>An async iterator over pages of dispatches.</p> YIELDS DESCRIPTION <code>AsyncIterator[Iterator[Dispatch]]</code> <p>A page of dispatches over which you can lazily iterate.</p> Source code in <code>frequenz/client/dispatch/_client.py</code> <pre><code>async def list(\n    self,\n    microgrid_id: int,\n    *,\n    component_selectors: Iterator[ComponentSelector] = iter(()),\n    start_from: datetime | None = None,\n    start_to: datetime | None = None,\n    end_from: datetime | None = None,\n    end_to: datetime | None = None,\n    active: bool | None = None,\n    dry_run: bool | None = None,\n    page_size: int | None = None,\n) -&gt; AsyncIterator[Iterator[Dispatch]]:\n    \"\"\"List dispatches.\n\n    This function handles pagination internally and returns an async iterator\n    over the dispatches. Pagination parameters like `page_size` and `page_token`\n    can be used, but they are mutually exclusive.\n\n    Example usage:\n\n    ```python\n    client = Client(key=\"key\", server_url=\"grpc://fz-0004.frequenz.io\")\n    async for page in client.list(microgrid_id=1):\n        for dispatch in page:\n            print(dispatch)\n    ```\n\n    Args:\n        microgrid_id: The microgrid_id to list dispatches for.\n        component_selectors: optional, list of component ids or categories to filter by.\n        start_from: optional, filter by start_time &gt;= start_from.\n        start_to: optional, filter by start_time &lt; start_to.\n        end_from: optional, filter by end_time &gt;= end_from.\n        end_to: optional, filter by end_time &lt; end_to.\n        active: optional, filter by active status.\n        dry_run: optional, filter by dry_run status.\n        page_size: optional, number of dispatches to return per page.\n\n    Returns:\n        An async iterator over pages of dispatches.\n\n    Yields:\n        A page of dispatches over which you can lazily iterate.\n    \"\"\"\n\n    def to_interval(\n        from_: datetime | None, to: datetime | None\n    ) -&gt; PBTimeIntervalFilter | None:\n        return (\n            PBTimeIntervalFilter(\n                **{\"from\": to_timestamp(from_)}, to=to_timestamp(to)\n            )\n            if from_ or to\n            else None\n        )\n\n    # Setup parameters\n    start_time_interval = to_interval(start_from, start_to)\n    end_time_interval = to_interval(end_from, end_to)\n    selectors = list(map(component_selector_to_protobuf, component_selectors))\n    filters = DispatchFilter(\n        selectors=selectors,\n        start_time_interval=start_time_interval,\n        end_time_interval=end_time_interval,\n        is_active=active,\n        is_dry_run=dry_run,\n    )\n\n    request = ListMicrogridDispatchesRequest(\n        microgrid_id=microgrid_id,\n        filter=filters,\n        pagination_params=(\n            PaginationParams(page_size=page_size) if page_size else None\n        ),\n    )\n\n    while True:\n        response = await cast(\n            Awaitable[ListMicrogridDispatchesResponse],\n            self.stub.ListMicrogridDispatches(request, metadata=self._metadata),\n        )\n\n        yield (Dispatch.from_protobuf(dispatch) for dispatch in response.dispatches)\n\n        if len(response.pagination_info.next_page_token):\n            request.pagination_params.CopyFrom(\n                PaginationParams(\n                    page_token=response.pagination_info.next_page_token\n                )\n            )\n        else:\n            break\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch.Client.stream","title":"stream","text":"<pre><code>stream(microgrid_id: int) -&gt; Receiver[DispatchEvent]\n</code></pre> <p>Receive a stream of dispatch events.</p> <p>This function returns a receiver channel that can be used to receive dispatch events. An event is one of [CREATE, UPDATE, DELETE].</p> <p>Example usage:</p> <pre><code>client = Client(key=\"key\", server_url=\"grpc://fz-0004.frequenz.io\")\nasync for message in client.stream(microgrid_id=1):\n    print(message.event, message.dispatch)\n</code></pre> PARAMETER DESCRIPTION <code>microgrid_id</code> <p>The microgrid_id to receive dispatches for.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Receiver[DispatchEvent]</code> <p>A receiver channel to receive the stream of dispatch events.</p> Source code in <code>frequenz/client/dispatch/_client.py</code> <pre><code>def stream(self, microgrid_id: int) -&gt; channels.Receiver[DispatchEvent]:\n    \"\"\"Receive a stream of dispatch events.\n\n    This function returns a receiver channel that can be used to receive\n    dispatch events.\n    An event is one of [CREATE, UPDATE, DELETE].\n\n    Example usage:\n\n    ```\n    client = Client(key=\"key\", server_url=\"grpc://fz-0004.frequenz.io\")\n    async for message in client.stream(microgrid_id=1):\n        print(message.event, message.dispatch)\n    ```\n\n    Args:\n        microgrid_id: The microgrid_id to receive dispatches for.\n\n    Returns:\n        A receiver channel to receive the stream of dispatch events.\n    \"\"\"\n    return self._get_stream(microgrid_id).new_receiver()\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch.Client.update","title":"update  <code>async</code>","text":"<pre><code>update(\n    *,\n    microgrid_id: int,\n    dispatch_id: int,\n    new_fields: dict[str, Any]\n) -&gt; Dispatch\n</code></pre> <p>Update a dispatch.</p> <p>The <code>new_fields</code> argument is a dictionary of fields to update. The keys are the field names, and the values are the new values for the fields.</p> <p>For recurrence fields, the keys are preceeded by \"recurrence.\".</p> <p>Note that updating <code>type</code> and <code>dry_run</code> is not supported.</p> PARAMETER DESCRIPTION <code>microgrid_id</code> <p>The microgrid_id to update the dispatch for.</p> <p> TYPE: <code>int</code> </p> <code>dispatch_id</code> <p>The dispatch_id to update.</p> <p> TYPE: <code>int</code> </p> <code>new_fields</code> <p>The fields to update.</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>Dispatch</code> <p>The updated dispatch.</p> <p> TYPE: <code>Dispatch</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If updating <code>type</code> or <code>dry_run</code>.</p> Source code in <code>frequenz/client/dispatch/_client.py</code> <pre><code>async def update(\n    self,\n    *,\n    microgrid_id: int,\n    dispatch_id: int,\n    new_fields: dict[str, Any],\n) -&gt; Dispatch:\n    \"\"\"Update a dispatch.\n\n    The `new_fields` argument is a dictionary of fields to update. The keys are\n    the field names, and the values are the new values for the fields.\n\n    For recurrence fields, the keys are preceeded by \"recurrence.\".\n\n    Note that updating `type` and `dry_run` is not supported.\n\n    Args:\n        microgrid_id: The microgrid_id to update the dispatch for.\n        dispatch_id: The dispatch_id to update.\n        new_fields: The fields to update.\n\n    Returns:\n        Dispatch: The updated dispatch.\n\n    Raises:\n        ValueError: If updating `type` or `dry_run`.\n    \"\"\"\n    msg = UpdateMicrogridDispatchRequest(\n        dispatch_id=dispatch_id, microgrid_id=microgrid_id\n    )\n\n    for key, val in new_fields.items():\n        path = key.split(\".\")\n\n        match path[0]:\n            case \"start_time\":\n                msg.update.start_time.CopyFrom(to_timestamp(val))\n            case \"duration\":\n                if val is None:\n                    msg.update.ClearField(\"duration\")\n                else:\n                    msg.update.duration = round(val.total_seconds())\n            case \"selector\":\n                msg.update.selector.CopyFrom(component_selector_to_protobuf(val))\n            case \"is_active\":\n                msg.update.is_active = val\n            case \"payload\":\n                msg.update.payload.update(val)\n            case \"active\":\n                msg.update.is_active = val\n                key = \"is_active\"\n            case \"recurrence\":\n                match path[1]:\n                    case \"freq\":\n                        msg.update.recurrence.freq = val\n                    # Proto uses \"freq\" instead of \"frequency\"\n                    case \"frequency\":\n                        msg.update.recurrence.freq = val\n                        # Correct the key to \"recurrence.freq\"\n                        key = \"recurrence.freq\"\n                    case \"interval\":\n                        msg.update.recurrence.interval = val\n                    case \"end_criteria\":\n                        msg.update.recurrence.end_criteria.CopyFrom(\n                            val.to_protobuf()\n                        )\n                    case \"byminutes\":\n                        msg.update.recurrence.byminutes.extend(val)\n                    case \"byhours\":\n                        msg.update.recurrence.byhours.extend(val)\n                    case \"byweekdays\":\n                        msg.update.recurrence.byweekdays.extend(val)\n                    case \"bymonthdays\":\n                        msg.update.recurrence.bymonthdays.extend(val)\n                    case \"bymonths\":\n                        msg.update.recurrence.bymonths.extend(val)\n                    case _:\n                        raise ValueError(f\"Unknown recurrence field: {path[1]}\")\n            case _:\n                raise ValueError(f\"Unknown field: {path[0]}\")\n\n        msg.update_mask.paths.append(key)\n\n    response = await cast(\n        Awaitable[UpdateMicrogridDispatchResponse],\n        self.stub.UpdateMicrogridDispatch(msg, metadata=self._metadata),\n    )\n\n    return Dispatch.from_protobuf(response.dispatch)\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/","title":"types","text":""},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types","title":"frequenz.client.dispatch.types","text":"<p>Type wrappers for the generated protobuf messages.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.ComponentSelector","title":"frequenz.client.dispatch.types.ComponentSelector  <code>module-attribute</code>","text":"<pre><code>ComponentSelector = list[int] | list[ComponentCategory]\n</code></pre> <p>A component selector specifying which components a dispatch targets.</p> <p>A component selector can be a list of component IDs or a list of categories.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types-classes","title":"Classes","text":""},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch","title":"frequenz.client.dispatch.types.Dispatch  <code>dataclass</code>","text":"<p>Represents a dispatch operation within a microgrid system.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>@dataclass(kw_only=True, frozen=True)\nclass Dispatch:\n    \"\"\"Represents a dispatch operation within a microgrid system.\"\"\"\n\n    id: int\n    \"\"\"The unique identifier for the dispatch.\"\"\"\n\n    type: str\n    \"\"\"User-defined information about the type of dispatch.\n\n    This is understood and processed by downstream applications.\"\"\"\n\n    start_time: datetime\n    \"\"\"The start time of the dispatch in UTC.\"\"\"\n\n    duration: timedelta | None\n    \"\"\"The duration of the dispatch, represented as a timedelta.\"\"\"\n\n    selector: ComponentSelector\n    \"\"\"The component selector specifying which components the dispatch targets.\"\"\"\n\n    active: bool\n    \"\"\"Indicates whether the dispatch is active and eligible for processing.\"\"\"\n\n    dry_run: bool\n    \"\"\"Indicates if the dispatch is a dry run.\n\n    Executed for logging and monitoring without affecting actual component states.\"\"\"\n\n    payload: dict[str, Any]\n    \"\"\"The dispatch payload containing arbitrary data.\n\n    It is structured as needed for the dispatch operation.\"\"\"\n\n    recurrence: RecurrenceRule\n    \"\"\"The recurrence rule for the dispatch.\n\n    Defining any repeating patterns or schedules.\"\"\"\n\n    create_time: datetime\n    \"\"\"The creation time of the dispatch in UTC. Set when a dispatch is created.\"\"\"\n\n    update_time: datetime\n    \"\"\"The last update time of the dispatch in UTC. Set when a dispatch is modified.\"\"\"\n\n    @classmethod\n    def from_protobuf(cls, pb_object: PBDispatch) -&gt; \"Dispatch\":\n        \"\"\"Convert a protobuf dispatch to a dispatch.\n\n        Args:\n            pb_object: The protobuf dispatch to convert.\n\n        Returns:\n            The converted dispatch.\n        \"\"\"\n        return Dispatch(\n            id=pb_object.metadata.dispatch_id,\n            type=pb_object.data.type,\n            create_time=to_datetime(pb_object.metadata.create_time),\n            update_time=to_datetime(pb_object.metadata.modification_time),\n            start_time=to_datetime(pb_object.data.start_time),\n            duration=(\n                timedelta(seconds=pb_object.data.duration)\n                if pb_object.data.duration\n                else None\n            ),\n            selector=component_selector_from_protobuf(pb_object.data.selector),\n            active=pb_object.data.is_active,\n            dry_run=pb_object.data.is_dry_run,\n            payload=MessageToDict(pb_object.data.payload),\n            recurrence=RecurrenceRule.from_protobuf(pb_object.data.recurrence),\n        )\n\n    def to_protobuf(self) -&gt; PBDispatch:\n        \"\"\"Convert a dispatch to a protobuf dispatch.\n\n        Returns:\n            The converted protobuf dispatch.\n        \"\"\"\n        payload = Struct()\n        payload.update(self.payload)\n\n        return PBDispatch(\n            metadata=DispatchMetadata(\n                dispatch_id=self.id,\n                create_time=to_timestamp(self.create_time),\n                modification_time=to_timestamp(self.update_time),\n            ),\n            data=DispatchData(\n                type=self.type,\n                start_time=to_timestamp(self.start_time),\n                duration=(\n                    round(self.duration.total_seconds()) if self.duration else None\n                ),\n                selector=component_selector_to_protobuf(self.selector),\n                is_active=self.active,\n                is_dry_run=self.dry_run,\n                payload=payload,\n                recurrence=self.recurrence.to_protobuf() if self.recurrence else None,\n            ),\n        )\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch.active","title":"active  <code>instance-attribute</code>","text":"<pre><code>active: bool\n</code></pre> <p>Indicates whether the dispatch is active and eligible for processing.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch.create_time","title":"create_time  <code>instance-attribute</code>","text":"<pre><code>create_time: datetime\n</code></pre> <p>The creation time of the dispatch in UTC. Set when a dispatch is created.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch.dry_run","title":"dry_run  <code>instance-attribute</code>","text":"<pre><code>dry_run: bool\n</code></pre> <p>Indicates if the dispatch is a dry run.</p> <p>Executed for logging and monitoring without affecting actual component states.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch.duration","title":"duration  <code>instance-attribute</code>","text":"<pre><code>duration: timedelta | None\n</code></pre> <p>The duration of the dispatch, represented as a timedelta.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: int\n</code></pre> <p>The unique identifier for the dispatch.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch.payload","title":"payload  <code>instance-attribute</code>","text":"<pre><code>payload: dict[str, Any]\n</code></pre> <p>The dispatch payload containing arbitrary data.</p> <p>It is structured as needed for the dispatch operation.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch.recurrence","title":"recurrence  <code>instance-attribute</code>","text":"<pre><code>recurrence: RecurrenceRule\n</code></pre> <p>The recurrence rule for the dispatch.</p> <p>Defining any repeating patterns or schedules.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch.selector","title":"selector  <code>instance-attribute</code>","text":"<pre><code>selector: ComponentSelector\n</code></pre> <p>The component selector specifying which components the dispatch targets.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch.start_time","title":"start_time  <code>instance-attribute</code>","text":"<pre><code>start_time: datetime\n</code></pre> <p>The start time of the dispatch in UTC.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: str\n</code></pre> <p>User-defined information about the type of dispatch.</p> <p>This is understood and processed by downstream applications.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch.update_time","title":"update_time  <code>instance-attribute</code>","text":"<pre><code>update_time: datetime\n</code></pre> <p>The last update time of the dispatch in UTC. Set when a dispatch is modified.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch.from_protobuf","title":"from_protobuf  <code>classmethod</code>","text":"<pre><code>from_protobuf(pb_object: Dispatch) -&gt; Dispatch\n</code></pre> <p>Convert a protobuf dispatch to a dispatch.</p> PARAMETER DESCRIPTION <code>pb_object</code> <p>The protobuf dispatch to convert.</p> <p> TYPE: <code>Dispatch</code> </p> RETURNS DESCRIPTION <code>Dispatch</code> <p>The converted dispatch.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>@classmethod\ndef from_protobuf(cls, pb_object: PBDispatch) -&gt; \"Dispatch\":\n    \"\"\"Convert a protobuf dispatch to a dispatch.\n\n    Args:\n        pb_object: The protobuf dispatch to convert.\n\n    Returns:\n        The converted dispatch.\n    \"\"\"\n    return Dispatch(\n        id=pb_object.metadata.dispatch_id,\n        type=pb_object.data.type,\n        create_time=to_datetime(pb_object.metadata.create_time),\n        update_time=to_datetime(pb_object.metadata.modification_time),\n        start_time=to_datetime(pb_object.data.start_time),\n        duration=(\n            timedelta(seconds=pb_object.data.duration)\n            if pb_object.data.duration\n            else None\n        ),\n        selector=component_selector_from_protobuf(pb_object.data.selector),\n        active=pb_object.data.is_active,\n        dry_run=pb_object.data.is_dry_run,\n        payload=MessageToDict(pb_object.data.payload),\n        recurrence=RecurrenceRule.from_protobuf(pb_object.data.recurrence),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch.to_protobuf","title":"to_protobuf","text":"<pre><code>to_protobuf() -&gt; Dispatch\n</code></pre> <p>Convert a dispatch to a protobuf dispatch.</p> RETURNS DESCRIPTION <code>Dispatch</code> <p>The converted protobuf dispatch.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>def to_protobuf(self) -&gt; PBDispatch:\n    \"\"\"Convert a dispatch to a protobuf dispatch.\n\n    Returns:\n        The converted protobuf dispatch.\n    \"\"\"\n    payload = Struct()\n    payload.update(self.payload)\n\n    return PBDispatch(\n        metadata=DispatchMetadata(\n            dispatch_id=self.id,\n            create_time=to_timestamp(self.create_time),\n            modification_time=to_timestamp(self.update_time),\n        ),\n        data=DispatchData(\n            type=self.type,\n            start_time=to_timestamp(self.start_time),\n            duration=(\n                round(self.duration.total_seconds()) if self.duration else None\n            ),\n            selector=component_selector_to_protobuf(self.selector),\n            is_active=self.active,\n            is_dry_run=self.dry_run,\n            payload=payload,\n            recurrence=self.recurrence.to_protobuf() if self.recurrence else None,\n        ),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.DispatchEvent","title":"frequenz.client.dispatch.types.DispatchEvent  <code>dataclass</code>","text":"<p>Represents an event that occurred during a dispatch operation.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>@dataclass(kw_only=True, frozen=True)\nclass DispatchEvent:\n    \"\"\"Represents an event that occurred during a dispatch operation.\"\"\"\n\n    dispatch: Dispatch\n    \"\"\"The dispatch associated with the event.\"\"\"\n\n    event: Event\n    \"\"\"The type of event that occurred.\"\"\"\n\n    @classmethod\n    def from_protobuf(\n        cls, pb_object: StreamMicrogridDispatchesResponse\n    ) -&gt; \"DispatchEvent\":\n        \"\"\"Convert a protobuf dispatch event to a dispatch event.\n\n        Args:\n            pb_object: The protobuf dispatch event to convert.\n\n        Returns:\n            The converted dispatch event.\n        \"\"\"\n        return DispatchEvent(\n            dispatch=Dispatch.from_protobuf(pb_object.dispatch),\n            event=Event(pb_object.event),\n        )\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.DispatchEvent-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.DispatchEvent.dispatch","title":"dispatch  <code>instance-attribute</code>","text":"<pre><code>dispatch: Dispatch\n</code></pre> <p>The dispatch associated with the event.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.DispatchEvent.event","title":"event  <code>instance-attribute</code>","text":"<pre><code>event: Event\n</code></pre> <p>The type of event that occurred.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.DispatchEvent-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.DispatchEvent.from_protobuf","title":"from_protobuf  <code>classmethod</code>","text":"<pre><code>from_protobuf(\n    pb_object: StreamMicrogridDispatchesResponse,\n) -&gt; DispatchEvent\n</code></pre> <p>Convert a protobuf dispatch event to a dispatch event.</p> PARAMETER DESCRIPTION <code>pb_object</code> <p>The protobuf dispatch event to convert.</p> <p> TYPE: <code>StreamMicrogridDispatchesResponse</code> </p> RETURNS DESCRIPTION <code>DispatchEvent</code> <p>The converted dispatch event.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>@classmethod\ndef from_protobuf(\n    cls, pb_object: StreamMicrogridDispatchesResponse\n) -&gt; \"DispatchEvent\":\n    \"\"\"Convert a protobuf dispatch event to a dispatch event.\n\n    Args:\n        pb_object: The protobuf dispatch event to convert.\n\n    Returns:\n        The converted dispatch event.\n    \"\"\"\n    return DispatchEvent(\n        dispatch=Dispatch.from_protobuf(pb_object.dispatch),\n        event=Event(pb_object.event),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.EndCriteria","title":"frequenz.client.dispatch.types.EndCriteria  <code>dataclass</code>","text":"<p>Controls when a recurring dispatch should end.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass EndCriteria:\n    \"\"\"Controls when a recurring dispatch should end.\"\"\"\n\n    count: int | None = None\n    \"\"\"The number of times this dispatch should recur.\"\"\"\n    until: datetime | None = None\n    \"\"\"The end time of this dispatch in UTC.\"\"\"\n\n    @classmethod\n    def from_protobuf(cls, pb_criteria: PBRecurrenceRule.EndCriteria) -&gt; \"EndCriteria\":\n        \"\"\"Convert a protobuf end criteria to an end criteria.\n\n        Args:\n            pb_criteria: The protobuf end criteria to convert.\n\n        Returns:\n            The converted end criteria.\n        \"\"\"\n        instance = cls()\n\n        match pb_criteria.WhichOneof(\"count_or_until\"):\n            case \"count\":\n                instance.count = pb_criteria.count\n            case \"until\":\n                instance.until = to_datetime(pb_criteria.until)\n        return instance\n\n    def to_protobuf(self) -&gt; PBRecurrenceRule.EndCriteria:\n        \"\"\"Convert an end criteria to a protobuf end criteria.\n\n        Returns:\n            The converted protobuf end criteria.\n        \"\"\"\n        pb_criteria = PBRecurrenceRule.EndCriteria()\n\n        if self.count is not None:\n            pb_criteria.count = self.count\n        elif self.until is not None:\n            pb_criteria.until.CopyFrom(to_timestamp(self.until))\n\n        return pb_criteria\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.EndCriteria-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.EndCriteria.count","title":"count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>count: int | None = None\n</code></pre> <p>The number of times this dispatch should recur.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.EndCriteria.until","title":"until  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>until: datetime | None = None\n</code></pre> <p>The end time of this dispatch in UTC.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.EndCriteria-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.EndCriteria.from_protobuf","title":"from_protobuf  <code>classmethod</code>","text":"<pre><code>from_protobuf(pb_criteria: EndCriteria) -&gt; EndCriteria\n</code></pre> <p>Convert a protobuf end criteria to an end criteria.</p> PARAMETER DESCRIPTION <code>pb_criteria</code> <p>The protobuf end criteria to convert.</p> <p> TYPE: <code>EndCriteria</code> </p> RETURNS DESCRIPTION <code>EndCriteria</code> <p>The converted end criteria.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>@classmethod\ndef from_protobuf(cls, pb_criteria: PBRecurrenceRule.EndCriteria) -&gt; \"EndCriteria\":\n    \"\"\"Convert a protobuf end criteria to an end criteria.\n\n    Args:\n        pb_criteria: The protobuf end criteria to convert.\n\n    Returns:\n        The converted end criteria.\n    \"\"\"\n    instance = cls()\n\n    match pb_criteria.WhichOneof(\"count_or_until\"):\n        case \"count\":\n            instance.count = pb_criteria.count\n        case \"until\":\n            instance.until = to_datetime(pb_criteria.until)\n    return instance\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.EndCriteria.to_protobuf","title":"to_protobuf","text":"<pre><code>to_protobuf() -&gt; EndCriteria\n</code></pre> <p>Convert an end criteria to a protobuf end criteria.</p> RETURNS DESCRIPTION <code>EndCriteria</code> <p>The converted protobuf end criteria.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>def to_protobuf(self) -&gt; PBRecurrenceRule.EndCriteria:\n    \"\"\"Convert an end criteria to a protobuf end criteria.\n\n    Returns:\n        The converted protobuf end criteria.\n    \"\"\"\n    pb_criteria = PBRecurrenceRule.EndCriteria()\n\n    if self.count is not None:\n        pb_criteria.count = self.count\n    elif self.until is not None:\n        pb_criteria.until.CopyFrom(to_timestamp(self.until))\n\n    return pb_criteria\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Event","title":"frequenz.client.dispatch.types.Event","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum representing the type of event that occurred during a dispatch operation.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>class Event(IntEnum):\n    \"\"\"Enum representing the type of event that occurred during a dispatch operation.\"\"\"\n\n    UNSPECIFIED = StreamMicrogridDispatchesResponse.Event.EVENT_UNSPECIFIED\n    CREATED = StreamMicrogridDispatchesResponse.Event.EVENT_CREATED\n    UPDATED = StreamMicrogridDispatchesResponse.Event.EVENT_UPDATED\n    DELETED = StreamMicrogridDispatchesResponse.Event.EVENT_DELETED\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Frequency","title":"frequenz.client.dispatch.types.Frequency","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum representing the frequency of the recurrence.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>class Frequency(IntEnum):\n    \"\"\"Enum representing the frequency of the recurrence.\"\"\"\n\n    UNSPECIFIED = PBRecurrenceRule.FREQUENCY_UNSPECIFIED\n    MINUTELY = PBRecurrenceRule.FREQUENCY_MINUTELY\n    HOURLY = PBRecurrenceRule.FREQUENCY_HOURLY\n    DAILY = PBRecurrenceRule.FREQUENCY_DAILY\n    WEEKLY = PBRecurrenceRule.FREQUENCY_WEEKLY\n    MONTHLY = PBRecurrenceRule.FREQUENCY_MONTHLY\n    YEARLY = PBRecurrenceRule.FREQUENCY_YEARLY\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.RecurrenceRule","title":"frequenz.client.dispatch.types.RecurrenceRule  <code>dataclass</code>","text":"<p>Ruleset governing when and how a dispatch should re-occur.</p> <p>Attributes follow the iCalendar specification (RFC5545) for recurrence rules.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass RecurrenceRule:\n    \"\"\"Ruleset governing when and how a dispatch should re-occur.\n\n    Attributes follow the iCalendar specification (RFC5545) for recurrence rules.\n    \"\"\"\n\n    frequency: Frequency = Frequency.UNSPECIFIED\n    \"\"\"The frequency specifier of this recurring dispatch.\"\"\"\n\n    interval: int = 0\n    \"\"\"How often this dispatch should recur, based on the frequency.\"\"\"\n\n    end_criteria: EndCriteria | None = None\n    \"\"\"When this dispatch should end.\n\n    Can recur a fixed number of times or until a given timestamp.\"\"\"\n\n    byminutes: list[int] = field(default_factory=list)\n    \"\"\"On which minute(s) of the hour the event occurs.\"\"\"\n\n    byhours: list[int] = field(default_factory=list)\n    \"\"\"On which hour(s) of the day the event occurs.\"\"\"\n\n    byweekdays: list[Weekday] = field(default_factory=list)\n    \"\"\"On which day(s) of the week the event occurs.\"\"\"\n\n    bymonthdays: list[int] = field(default_factory=list)\n    \"\"\"On which day(s) of the month the event occurs.\"\"\"\n\n    bymonths: list[int] = field(default_factory=list)\n    \"\"\"On which month(s) of the year the event occurs.\"\"\"\n\n    @classmethod\n    def from_protobuf(cls, pb_rule: PBRecurrenceRule) -&gt; \"RecurrenceRule\":\n        \"\"\"Convert a protobuf recurrence rule to a recurrence rule.\n\n        Args:\n            pb_rule: The protobuf recurrence rule to convert.\n\n        Returns:\n            The converted recurrence rule.\n        \"\"\"\n        return RecurrenceRule(\n            frequency=Frequency(pb_rule.freq),\n            interval=pb_rule.interval,\n            end_criteria=(\n                EndCriteria.from_protobuf(pb_rule.end_criteria)\n                if pb_rule.HasField(\"end_criteria\")\n                else None\n            ),\n            byminutes=list(pb_rule.byminutes),\n            byhours=list(pb_rule.byhours),\n            byweekdays=[Weekday(day) for day in pb_rule.byweekdays],\n            bymonthdays=list(pb_rule.bymonthdays),\n            bymonths=list(pb_rule.bymonths),\n        )\n\n    def to_protobuf(self) -&gt; PBRecurrenceRule:\n        \"\"\"Convert a recurrence rule to a protobuf recurrence rule.\n\n        Returns:\n            The converted protobuf recurrence rule.\n        \"\"\"\n        pb_rule = PBRecurrenceRule()\n\n        pb_rule.freq = self.frequency.value\n        pb_rule.interval = self.interval\n        if self.end_criteria is not None:\n            pb_rule.end_criteria.CopyFrom(self.end_criteria.to_protobuf())\n        pb_rule.byminutes.extend(self.byminutes)\n        pb_rule.byhours.extend(self.byhours)\n        pb_rule.byweekdays.extend([day.value for day in self.byweekdays])\n        pb_rule.bymonthdays.extend(self.bymonthdays)\n        pb_rule.bymonths.extend(self.bymonths)\n\n        return pb_rule\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.RecurrenceRule-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.RecurrenceRule.byhours","title":"byhours  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>byhours: list[int] = field(default_factory=list)\n</code></pre> <p>On which hour(s) of the day the event occurs.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.RecurrenceRule.byminutes","title":"byminutes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>byminutes: list[int] = field(default_factory=list)\n</code></pre> <p>On which minute(s) of the hour the event occurs.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.RecurrenceRule.bymonthdays","title":"bymonthdays  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bymonthdays: list[int] = field(default_factory=list)\n</code></pre> <p>On which day(s) of the month the event occurs.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.RecurrenceRule.bymonths","title":"bymonths  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bymonths: list[int] = field(default_factory=list)\n</code></pre> <p>On which month(s) of the year the event occurs.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.RecurrenceRule.byweekdays","title":"byweekdays  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>byweekdays: list[Weekday] = field(default_factory=list)\n</code></pre> <p>On which day(s) of the week the event occurs.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.RecurrenceRule.end_criteria","title":"end_criteria  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>end_criteria: EndCriteria | None = None\n</code></pre> <p>When this dispatch should end.</p> <p>Can recur a fixed number of times or until a given timestamp.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.RecurrenceRule.frequency","title":"frequency  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>frequency: Frequency = UNSPECIFIED\n</code></pre> <p>The frequency specifier of this recurring dispatch.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.RecurrenceRule.interval","title":"interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interval: int = 0\n</code></pre> <p>How often this dispatch should recur, based on the frequency.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.RecurrenceRule-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.RecurrenceRule.from_protobuf","title":"from_protobuf  <code>classmethod</code>","text":"<pre><code>from_protobuf(pb_rule: RecurrenceRule) -&gt; RecurrenceRule\n</code></pre> <p>Convert a protobuf recurrence rule to a recurrence rule.</p> PARAMETER DESCRIPTION <code>pb_rule</code> <p>The protobuf recurrence rule to convert.</p> <p> TYPE: <code>RecurrenceRule</code> </p> RETURNS DESCRIPTION <code>RecurrenceRule</code> <p>The converted recurrence rule.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>@classmethod\ndef from_protobuf(cls, pb_rule: PBRecurrenceRule) -&gt; \"RecurrenceRule\":\n    \"\"\"Convert a protobuf recurrence rule to a recurrence rule.\n\n    Args:\n        pb_rule: The protobuf recurrence rule to convert.\n\n    Returns:\n        The converted recurrence rule.\n    \"\"\"\n    return RecurrenceRule(\n        frequency=Frequency(pb_rule.freq),\n        interval=pb_rule.interval,\n        end_criteria=(\n            EndCriteria.from_protobuf(pb_rule.end_criteria)\n            if pb_rule.HasField(\"end_criteria\")\n            else None\n        ),\n        byminutes=list(pb_rule.byminutes),\n        byhours=list(pb_rule.byhours),\n        byweekdays=[Weekday(day) for day in pb_rule.byweekdays],\n        bymonthdays=list(pb_rule.bymonthdays),\n        bymonths=list(pb_rule.bymonths),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.RecurrenceRule.to_protobuf","title":"to_protobuf","text":"<pre><code>to_protobuf() -&gt; RecurrenceRule\n</code></pre> <p>Convert a recurrence rule to a protobuf recurrence rule.</p> RETURNS DESCRIPTION <code>RecurrenceRule</code> <p>The converted protobuf recurrence rule.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>def to_protobuf(self) -&gt; PBRecurrenceRule:\n    \"\"\"Convert a recurrence rule to a protobuf recurrence rule.\n\n    Returns:\n        The converted protobuf recurrence rule.\n    \"\"\"\n    pb_rule = PBRecurrenceRule()\n\n    pb_rule.freq = self.frequency.value\n    pb_rule.interval = self.interval\n    if self.end_criteria is not None:\n        pb_rule.end_criteria.CopyFrom(self.end_criteria.to_protobuf())\n    pb_rule.byminutes.extend(self.byminutes)\n    pb_rule.byhours.extend(self.byhours)\n    pb_rule.byweekdays.extend([day.value for day in self.byweekdays])\n    pb_rule.bymonthdays.extend(self.bymonthdays)\n    pb_rule.bymonths.extend(self.bymonths)\n\n    return pb_rule\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.TimeIntervalFilter","title":"frequenz.client.dispatch.types.TimeIntervalFilter  <code>dataclass</code>","text":"<p>Filter for a time interval.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass TimeIntervalFilter:\n    \"\"\"Filter for a time interval.\"\"\"\n\n    start_from: datetime | None\n    \"\"\"Filter by start_time &gt;= start_from.\"\"\"\n\n    start_to: datetime | None\n    \"\"\"Filter by start_time &lt; start_to.\"\"\"\n\n    end_from: datetime | None\n    \"\"\"Filter by end_time &gt;= end_from.\"\"\"\n\n    end_to: datetime | None\n    \"\"\"Filter by end_time &lt; end_to.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.TimeIntervalFilter-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.TimeIntervalFilter.end_from","title":"end_from  <code>instance-attribute</code>","text":"<pre><code>end_from: datetime | None\n</code></pre> <p>Filter by end_time &gt;= end_from.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.TimeIntervalFilter.end_to","title":"end_to  <code>instance-attribute</code>","text":"<pre><code>end_to: datetime | None\n</code></pre> <p>Filter by end_time &lt; end_to.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.TimeIntervalFilter.start_from","title":"start_from  <code>instance-attribute</code>","text":"<pre><code>start_from: datetime | None\n</code></pre> <p>Filter by start_time &gt;= start_from.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.TimeIntervalFilter.start_to","title":"start_to  <code>instance-attribute</code>","text":"<pre><code>start_to: datetime | None\n</code></pre> <p>Filter by start_time &lt; start_to.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Weekday","title":"frequenz.client.dispatch.types.Weekday","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum representing the day of the week.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>class Weekday(IntEnum):\n    \"\"\"Enum representing the day of the week.\"\"\"\n\n    UNSPECIFIED = PBRecurrenceRule.WEEKDAY_UNSPECIFIED\n    MONDAY = PBRecurrenceRule.WEEKDAY_MONDAY\n    TUESDAY = PBRecurrenceRule.WEEKDAY_TUESDAY\n    WEDNESDAY = PBRecurrenceRule.WEEKDAY_WEDNESDAY\n    THURSDAY = PBRecurrenceRule.WEEKDAY_THURSDAY\n    FRIDAY = PBRecurrenceRule.WEEKDAY_FRIDAY\n    SATURDAY = PBRecurrenceRule.WEEKDAY_SATURDAY\n    SUNDAY = PBRecurrenceRule.WEEKDAY_SUNDAY\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.component_selector_from_protobuf","title":"frequenz.client.dispatch.types.component_selector_from_protobuf","text":"<pre><code>component_selector_from_protobuf(\n    pb_selector: ComponentSelector,\n) -&gt; ComponentSelector\n</code></pre> <p>Convert a protobuf component selector to a component selector.</p> PARAMETER DESCRIPTION <code>pb_selector</code> <p>The protobuf component selector to convert.</p> <p> TYPE: <code>ComponentSelector</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the protobuf component selector is invalid.</p> RETURNS DESCRIPTION <code>ComponentSelector</code> <p>The converted component selector.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>def component_selector_from_protobuf(\n    pb_selector: PBComponentSelector,\n) -&gt; ComponentSelector:\n    \"\"\"Convert a protobuf component selector to a component selector.\n\n    Args:\n        pb_selector: The protobuf component selector to convert.\n\n    Raises:\n        ValueError: If the protobuf component selector is invalid.\n\n    Returns:\n        The converted component selector.\n    \"\"\"\n    match pb_selector.WhichOneof(\"selector\"):\n        case \"component_ids\":\n            id_list: list[int] = list(pb_selector.component_ids.ids)\n            return id_list\n        case \"component_categories\":\n            category_list: list[ComponentCategory] = list(\n                map(\n                    ComponentCategory.from_proto,\n                    pb_selector.component_categories.categories,\n                )\n            )\n            return category_list\n        case _:\n            raise ValueError(\"Invalid component selector\")\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.component_selector_to_protobuf","title":"frequenz.client.dispatch.types.component_selector_to_protobuf","text":"<pre><code>component_selector_to_protobuf(\n    selector: ComponentSelector,\n) -&gt; ComponentSelector\n</code></pre> <p>Convert a component selector to a protobuf component selector.</p> PARAMETER DESCRIPTION <code>selector</code> <p>The component selector to convert.</p> <p> TYPE: <code>ComponentSelector</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the component selector is invalid.</p> RETURNS DESCRIPTION <code>ComponentSelector</code> <p>The converted protobuf component selector.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>def component_selector_to_protobuf(\n    selector: ComponentSelector,\n) -&gt; PBComponentSelector:\n    \"\"\"Convert a component selector to a protobuf component selector.\n\n    Args:\n        selector: The component selector to convert.\n\n    Raises:\n        ValueError: If the component selector is invalid.\n\n    Returns:\n        The converted protobuf component selector.\n    \"\"\"\n    pb_selector = PBComponentSelector()\n    match selector:\n        case list(component_ids) if all(isinstance(id, int) for id in component_ids):\n            pb_selector.component_ids.ids.extend(cast(list[int], component_ids))\n        case list(categories) if all(\n            isinstance(cat, ComponentCategory) for cat in categories\n        ):\n            pb_selector.component_categories.categories.extend(\n                map(\n                    lambda cat: cat.to_proto(),\n                    cast(list[ComponentCategory], categories),\n                )\n            )\n        case _:\n            raise ValueError(\"Invalid component selector\")\n    return pb_selector\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/","title":"Index","text":""},{"location":"reference/frequenz/client/dispatch/test/#frequenz.client.dispatch.test","title":"frequenz.client.dispatch.test","text":"<p>Helpful utilities for testing with the dispatch client.</p>"},{"location":"reference/frequenz/client/dispatch/test/client/","title":"client","text":""},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client","title":"frequenz.client.dispatch.test.client","text":"<p>Fake client for testing.</p>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.ALL_KEY","title":"frequenz.client.dispatch.test.client.ALL_KEY  <code>module-attribute</code>","text":"<pre><code>ALL_KEY = 'all'\n</code></pre> <p>Key that has access to all resources in the FakeService.</p>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.NONE_KEY","title":"frequenz.client.dispatch.test.client.NONE_KEY  <code>module-attribute</code>","text":"<pre><code>NONE_KEY = 'none'\n</code></pre> <p>Key that has no access to any resources in the FakeService.</p>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client-classes","title":"Classes","text":""},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient","title":"frequenz.client.dispatch.test.client.FakeClient","text":"<p>               Bases: <code>Client</code></p> <p>Fake client for testing.</p> <p>This client uses a fake service to simulate the dispatch api.</p> Source code in <code>frequenz/client/dispatch/test/client.py</code> <pre><code>class FakeClient(Client):\n    \"\"\"Fake client for testing.\n\n    This client uses a fake service to simulate the dispatch api.\n    \"\"\"\n\n    def __init__(\n        self,\n    ) -&gt; None:\n        \"\"\"Initialize the mock client.\"\"\"\n        super().__init__(server_url=\"mock\", key=ALL_KEY, connect=False)\n        self._stuba: FakeService = FakeService()\n\n    @property\n    def stub(self) -&gt; FakeService:  # type: ignore\n        \"\"\"The fake service.\n\n        Returns:\n            FakeService: The fake service.\n        \"\"\"\n        return self._stuba\n\n    def dispatches(self, microgrid_id: int) -&gt; list[Dispatch]:\n        \"\"\"List of dispatches.\n\n        Args:\n            microgrid_id: The microgrid id.\n\n        Returns:\n            list[Dispatch]: The list of dispatches\n        \"\"\"\n        return self._service.dispatches.get(microgrid_id, [])\n\n    def set_dispatches(self, microgrid_id: int, value: list[Dispatch]) -&gt; None:\n        \"\"\"Set the list of dispatches.\n\n        Args:\n            microgrid_id: The microgrid id.\n            value: The list of dispatches to set.\n        \"\"\"\n        self._service.dispatches[microgrid_id] = value\n\n    @property\n    def _service(self) -&gt; FakeService:\n        \"\"\"The fake service.\n\n        Returns:\n            FakeService: The fake service.\n        \"\"\"\n        return self._stuba\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient.channel","title":"channel  <code>property</code>","text":"<pre><code>channel: Channel\n</code></pre> <p>The underlying gRPC channel used to communicate with the server.</p> Warning <p>This channel is provided as a last resort for advanced users. It is not recommended to use this property directly unless you know what you are doing and you don't care about being tied to a specific gRPC library.</p> RAISES DESCRIPTION <code>ClientNotConnected</code> <p>If the client is not connected to the server.</p>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient.channel_defaults","title":"channel_defaults  <code>property</code>","text":"<pre><code>channel_defaults: ChannelOptions\n</code></pre> <p>The default options for the gRPC channel.</p>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient.is_connected","title":"is_connected  <code>property</code>","text":"<pre><code>is_connected: bool\n</code></pre> <p>Whether the client is connected to the server.</p>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient.server_url","title":"server_url  <code>property</code>","text":"<pre><code>server_url: str\n</code></pre> <p>The URL of the server.</p>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient.streams","title":"streams  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>streams: dict[\n    int,\n    GrpcStreamBroadcaster[\n        StreamMicrogridDispatchesResponse, DispatchEvent\n    ],\n] = {}\n</code></pre> <p>A dictionary of streamers, keyed by microgrid_id.</p>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient.stub","title":"stub  <code>property</code>","text":"<pre><code>stub: FakeService\n</code></pre> <p>The fake service.</p> RETURNS DESCRIPTION <code>FakeService</code> <p>The fake service.</p> <p> TYPE: <code>FakeService</code> </p>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter a context manager.</p> Source code in <code>frequenz/client/base/client.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enter a context manager.\"\"\"\n    self.connect()\n    return self\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    _exc_type: type[BaseException] | None,\n    _exc_val: BaseException | None,\n    _exc_tb: Any | None,\n) -&gt; bool | None\n</code></pre> <p>Exit a context manager.</p> Source code in <code>frequenz/client/base/client.py</code> <pre><code>async def __aexit__(\n    self,\n    _exc_type: type[BaseException] | None,\n    _exc_val: BaseException | None,\n    _exc_tb: Any | None,\n) -&gt; bool | None:\n    \"\"\"Exit a context manager.\"\"\"\n    if self._channel is None:\n        return None\n    result = await self._channel.__aexit__(_exc_type, _exc_val, _exc_tb)\n    self._channel = None\n    self._stub = None\n    return result\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> <p>Initialize the mock client.</p> Source code in <code>frequenz/client/dispatch/test/client.py</code> <pre><code>def __init__(\n    self,\n) -&gt; None:\n    \"\"\"Initialize the mock client.\"\"\"\n    super().__init__(server_url=\"mock\", key=ALL_KEY, connect=False)\n    self._stuba: FakeService = FakeService()\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient.connect","title":"connect","text":"<pre><code>connect(server_url: str | None = None) -&gt; None\n</code></pre> <p>Connect to the server, possibly using a new URL.</p> <p>If the client is already connected and the URL is the same as the previous URL, this method does nothing. If you want to force a reconnection, you can call disconnect() first.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The URL of the server to connect to. If not provided, the previously used URL is used.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/client/base/client.py</code> <pre><code>def connect(self, server_url: str | None = None) -&gt; None:\n    \"\"\"Connect to the server, possibly using a new URL.\n\n    If the client is already connected and the URL is the same as the previous URL,\n    this method does nothing. If you want to force a reconnection, you can call\n    [disconnect()][frequenz.client.base.client.BaseApiClient.disconnect] first.\n\n    Args:\n        server_url: The URL of the server to connect to. If not provided, the\n            previously used URL is used.\n    \"\"\"\n    if server_url is not None and server_url != self._server_url:  # URL changed\n        self._server_url = server_url\n    elif self.is_connected:\n        return\n    self._channel = parse_grpc_uri(self._server_url, self._channel_defaults)\n    self._stub = self._create_stub(self._channel)\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient.create","title":"create  <code>async</code>","text":"<pre><code>create(\n    microgrid_id: int,\n    type: str,\n    start_time: datetime,\n    duration: timedelta | None,\n    selector: ComponentSelector,\n    *,\n    active: bool = True,\n    dry_run: bool = False,\n    payload: dict[str, Any] | None = None,\n    recurrence: RecurrenceRule | None = None\n) -&gt; Dispatch\n</code></pre> <p>Create a dispatch.</p> <p>Will try to return the created dispatch, identifying it by the same fields as the request.</p> PARAMETER DESCRIPTION <code>microgrid_id</code> <p>The microgrid_id to create the dispatch for.</p> <p> TYPE: <code>int</code> </p> <code>type</code> <p>User defined string to identify the dispatch type.</p> <p> TYPE: <code>str</code> </p> <code>start_time</code> <p>The start time of the dispatch.</p> <p> TYPE: <code>datetime</code> </p> <code>duration</code> <p>The duration of the dispatch. Can be <code>None</code> for infinite or no-duration dispatches (e.g. switching a component on).</p> <p> TYPE: <code>timedelta | None</code> </p> <code>selector</code> <p>The component selector for the dispatch.</p> <p> TYPE: <code>ComponentSelector</code> </p> <code>active</code> <p>The active status of the dispatch.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>dry_run</code> <p>The dry_run status of the dispatch.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>payload</code> <p>The payload of the dispatch.</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>recurrence</code> <p>The recurrence rule of the dispatch.</p> <p> TYPE: <code>RecurrenceRule | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Dispatch</code> <p>The created dispatch</p> <p> TYPE: <code>Dispatch</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If start_time is in the past.</p> Source code in <code>frequenz/client/dispatch/_client.py</code> <pre><code>async def create(  # pylint: disable=too-many-positional-arguments\n    self,\n    microgrid_id: int,\n    type: str,  # pylint: disable=redefined-builtin\n    start_time: datetime,\n    duration: timedelta | None,\n    selector: ComponentSelector,\n    *,\n    active: bool = True,\n    dry_run: bool = False,\n    payload: dict[str, Any] | None = None,\n    recurrence: RecurrenceRule | None = None,\n) -&gt; Dispatch:\n    \"\"\"Create a dispatch.\n\n    Will try to return the created dispatch, identifying it by\n    the same fields as the request.\n\n    Args:\n        microgrid_id: The microgrid_id to create the dispatch for.\n        type: User defined string to identify the dispatch type.\n        start_time: The start time of the dispatch.\n        duration: The duration of the dispatch. Can be `None` for infinite\n            or no-duration dispatches (e.g. switching a component on).\n        selector: The component selector for the dispatch.\n        active: The active status of the dispatch.\n        dry_run: The dry_run status of the dispatch.\n        payload: The payload of the dispatch.\n        recurrence: The recurrence rule of the dispatch.\n\n    Returns:\n        Dispatch: The created dispatch\n\n    Raises:\n        ValueError: If start_time is in the past.\n    \"\"\"\n    if start_time &lt;= datetime.now(tz=start_time.tzinfo):\n        raise ValueError(\"start_time must not be in the past\")\n\n    # Raise if it's not UTC\n    if start_time.tzinfo is None or start_time.tzinfo.utcoffset(start_time) is None:\n        raise ValueError(\"start_time must be timezone aware\")\n\n    request = DispatchCreateRequest(\n        microgrid_id=microgrid_id,\n        type=type,\n        start_time=start_time,\n        duration=duration,\n        selector=selector,\n        active=active,\n        dry_run=dry_run,\n        payload=payload or {},\n        recurrence=recurrence,\n    )\n\n    response = await cast(\n        Awaitable[CreateMicrogridDispatchResponse],\n        self.stub.CreateMicrogridDispatch(\n            request.to_protobuf(), metadata=self._metadata\n        ),\n    )\n\n    return Dispatch.from_protobuf(response.dispatch)\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(*, microgrid_id: int, dispatch_id: int) -&gt; None\n</code></pre> <p>Delete a dispatch.</p> PARAMETER DESCRIPTION <code>microgrid_id</code> <p>The microgrid_id to delete the dispatch for.</p> <p> TYPE: <code>int</code> </p> <code>dispatch_id</code> <p>The dispatch_id to delete.</p> <p> TYPE: <code>int</code> </p> Source code in <code>frequenz/client/dispatch/_client.py</code> <pre><code>async def delete(self, *, microgrid_id: int, dispatch_id: int) -&gt; None:\n    \"\"\"Delete a dispatch.\n\n    Args:\n        microgrid_id: The microgrid_id to delete the dispatch for.\n        dispatch_id: The dispatch_id to delete.\n    \"\"\"\n    request = DeleteMicrogridDispatchRequest(\n        dispatch_id=dispatch_id, microgrid_id=microgrid_id\n    )\n    await cast(\n        Awaitable[None],\n        self.stub.DeleteMicrogridDispatch(request, metadata=self._metadata),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient.disconnect","title":"disconnect  <code>async</code>","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the server.</p> <p>If the client is not connected, this method does nothing.</p> Source code in <code>frequenz/client/base/client.py</code> <pre><code>async def disconnect(self) -&gt; None:\n    \"\"\"Disconnect from the server.\n\n    If the client is not connected, this method does nothing.\n    \"\"\"\n    await self.__aexit__(None, None, None)\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient.dispatches","title":"dispatches","text":"<pre><code>dispatches(microgrid_id: int) -&gt; list[Dispatch]\n</code></pre> <p>List of dispatches.</p> PARAMETER DESCRIPTION <code>microgrid_id</code> <p>The microgrid id.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>list[Dispatch]</code> <p>list[Dispatch]: The list of dispatches</p> Source code in <code>frequenz/client/dispatch/test/client.py</code> <pre><code>def dispatches(self, microgrid_id: int) -&gt; list[Dispatch]:\n    \"\"\"List of dispatches.\n\n    Args:\n        microgrid_id: The microgrid id.\n\n    Returns:\n        list[Dispatch]: The list of dispatches\n    \"\"\"\n    return self._service.dispatches.get(microgrid_id, [])\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient.get","title":"get  <code>async</code>","text":"<pre><code>get(*, microgrid_id: int, dispatch_id: int) -&gt; Dispatch\n</code></pre> <p>Get a dispatch.</p> PARAMETER DESCRIPTION <code>microgrid_id</code> <p>The microgrid_id to get the dispatch for.</p> <p> TYPE: <code>int</code> </p> <code>dispatch_id</code> <p>The dispatch_id to get.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Dispatch</code> <p>The dispatch.</p> <p> TYPE: <code>Dispatch</code> </p> Source code in <code>frequenz/client/dispatch/_client.py</code> <pre><code>async def get(self, *, microgrid_id: int, dispatch_id: int) -&gt; Dispatch:\n    \"\"\"Get a dispatch.\n\n    Args:\n        microgrid_id: The microgrid_id to get the dispatch for.\n        dispatch_id: The dispatch_id to get.\n\n    Returns:\n        Dispatch: The dispatch.\n    \"\"\"\n    request = GetMicrogridDispatchRequest(\n        dispatch_id=dispatch_id, microgrid_id=microgrid_id\n    )\n    response = await cast(\n        Awaitable[GetMicrogridDispatchResponse],\n        self.stub.GetMicrogridDispatch(request, metadata=self._metadata),\n    )\n    return Dispatch.from_protobuf(response.dispatch)\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient.list","title":"list  <code>async</code>","text":"<pre><code>list(\n    microgrid_id: int,\n    *,\n    component_selectors: Iterator[ComponentSelector] = iter(\n        ()\n    ),\n    start_from: datetime | None = None,\n    start_to: datetime | None = None,\n    end_from: datetime | None = None,\n    end_to: datetime | None = None,\n    active: bool | None = None,\n    dry_run: bool | None = None,\n    page_size: int | None = None\n) -&gt; AsyncIterator[Iterator[Dispatch]]\n</code></pre> <p>List dispatches.</p> <p>This function handles pagination internally and returns an async iterator over the dispatches. Pagination parameters like <code>page_size</code> and <code>page_token</code> can be used, but they are mutually exclusive.</p> <p>Example usage:</p> <pre><code>client = Client(key=\"key\", server_url=\"grpc://fz-0004.frequenz.io\")\nasync for page in client.list(microgrid_id=1):\n    for dispatch in page:\n        print(dispatch)\n</code></pre> PARAMETER DESCRIPTION <code>microgrid_id</code> <p>The microgrid_id to list dispatches for.</p> <p> TYPE: <code>int</code> </p> <code>component_selectors</code> <p>optional, list of component ids or categories to filter by.</p> <p> TYPE: <code>Iterator[ComponentSelector]</code> DEFAULT: <code>iter(())</code> </p> <code>start_from</code> <p>optional, filter by start_time &gt;= start_from.</p> <p> TYPE: <code>datetime | None</code> DEFAULT: <code>None</code> </p> <code>start_to</code> <p>optional, filter by start_time &lt; start_to.</p> <p> TYPE: <code>datetime | None</code> DEFAULT: <code>None</code> </p> <code>end_from</code> <p>optional, filter by end_time &gt;= end_from.</p> <p> TYPE: <code>datetime | None</code> DEFAULT: <code>None</code> </p> <code>end_to</code> <p>optional, filter by end_time &lt; end_to.</p> <p> TYPE: <code>datetime | None</code> DEFAULT: <code>None</code> </p> <code>active</code> <p>optional, filter by active status.</p> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> <code>dry_run</code> <p>optional, filter by dry_run status.</p> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> <code>page_size</code> <p>optional, number of dispatches to return per page.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>AsyncIterator[Iterator[Dispatch]]</code> <p>An async iterator over pages of dispatches.</p> YIELDS DESCRIPTION <code>AsyncIterator[Iterator[Dispatch]]</code> <p>A page of dispatches over which you can lazily iterate.</p> Source code in <code>frequenz/client/dispatch/_client.py</code> <pre><code>async def list(\n    self,\n    microgrid_id: int,\n    *,\n    component_selectors: Iterator[ComponentSelector] = iter(()),\n    start_from: datetime | None = None,\n    start_to: datetime | None = None,\n    end_from: datetime | None = None,\n    end_to: datetime | None = None,\n    active: bool | None = None,\n    dry_run: bool | None = None,\n    page_size: int | None = None,\n) -&gt; AsyncIterator[Iterator[Dispatch]]:\n    \"\"\"List dispatches.\n\n    This function handles pagination internally and returns an async iterator\n    over the dispatches. Pagination parameters like `page_size` and `page_token`\n    can be used, but they are mutually exclusive.\n\n    Example usage:\n\n    ```python\n    client = Client(key=\"key\", server_url=\"grpc://fz-0004.frequenz.io\")\n    async for page in client.list(microgrid_id=1):\n        for dispatch in page:\n            print(dispatch)\n    ```\n\n    Args:\n        microgrid_id: The microgrid_id to list dispatches for.\n        component_selectors: optional, list of component ids or categories to filter by.\n        start_from: optional, filter by start_time &gt;= start_from.\n        start_to: optional, filter by start_time &lt; start_to.\n        end_from: optional, filter by end_time &gt;= end_from.\n        end_to: optional, filter by end_time &lt; end_to.\n        active: optional, filter by active status.\n        dry_run: optional, filter by dry_run status.\n        page_size: optional, number of dispatches to return per page.\n\n    Returns:\n        An async iterator over pages of dispatches.\n\n    Yields:\n        A page of dispatches over which you can lazily iterate.\n    \"\"\"\n\n    def to_interval(\n        from_: datetime | None, to: datetime | None\n    ) -&gt; PBTimeIntervalFilter | None:\n        return (\n            PBTimeIntervalFilter(\n                **{\"from\": to_timestamp(from_)}, to=to_timestamp(to)\n            )\n            if from_ or to\n            else None\n        )\n\n    # Setup parameters\n    start_time_interval = to_interval(start_from, start_to)\n    end_time_interval = to_interval(end_from, end_to)\n    selectors = list(map(component_selector_to_protobuf, component_selectors))\n    filters = DispatchFilter(\n        selectors=selectors,\n        start_time_interval=start_time_interval,\n        end_time_interval=end_time_interval,\n        is_active=active,\n        is_dry_run=dry_run,\n    )\n\n    request = ListMicrogridDispatchesRequest(\n        microgrid_id=microgrid_id,\n        filter=filters,\n        pagination_params=(\n            PaginationParams(page_size=page_size) if page_size else None\n        ),\n    )\n\n    while True:\n        response = await cast(\n            Awaitable[ListMicrogridDispatchesResponse],\n            self.stub.ListMicrogridDispatches(request, metadata=self._metadata),\n        )\n\n        yield (Dispatch.from_protobuf(dispatch) for dispatch in response.dispatches)\n\n        if len(response.pagination_info.next_page_token):\n            request.pagination_params.CopyFrom(\n                PaginationParams(\n                    page_token=response.pagination_info.next_page_token\n                )\n            )\n        else:\n            break\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient.set_dispatches","title":"set_dispatches","text":"<pre><code>set_dispatches(\n    microgrid_id: int, value: list[Dispatch]\n) -&gt; None\n</code></pre> <p>Set the list of dispatches.</p> PARAMETER DESCRIPTION <code>microgrid_id</code> <p>The microgrid id.</p> <p> TYPE: <code>int</code> </p> <code>value</code> <p>The list of dispatches to set.</p> <p> TYPE: <code>list[Dispatch]</code> </p> Source code in <code>frequenz/client/dispatch/test/client.py</code> <pre><code>def set_dispatches(self, microgrid_id: int, value: list[Dispatch]) -&gt; None:\n    \"\"\"Set the list of dispatches.\n\n    Args:\n        microgrid_id: The microgrid id.\n        value: The list of dispatches to set.\n    \"\"\"\n    self._service.dispatches[microgrid_id] = value\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient.stream","title":"stream","text":"<pre><code>stream(microgrid_id: int) -&gt; Receiver[DispatchEvent]\n</code></pre> <p>Receive a stream of dispatch events.</p> <p>This function returns a receiver channel that can be used to receive dispatch events. An event is one of [CREATE, UPDATE, DELETE].</p> <p>Example usage:</p> <pre><code>client = Client(key=\"key\", server_url=\"grpc://fz-0004.frequenz.io\")\nasync for message in client.stream(microgrid_id=1):\n    print(message.event, message.dispatch)\n</code></pre> PARAMETER DESCRIPTION <code>microgrid_id</code> <p>The microgrid_id to receive dispatches for.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Receiver[DispatchEvent]</code> <p>A receiver channel to receive the stream of dispatch events.</p> Source code in <code>frequenz/client/dispatch/_client.py</code> <pre><code>def stream(self, microgrid_id: int) -&gt; channels.Receiver[DispatchEvent]:\n    \"\"\"Receive a stream of dispatch events.\n\n    This function returns a receiver channel that can be used to receive\n    dispatch events.\n    An event is one of [CREATE, UPDATE, DELETE].\n\n    Example usage:\n\n    ```\n    client = Client(key=\"key\", server_url=\"grpc://fz-0004.frequenz.io\")\n    async for message in client.stream(microgrid_id=1):\n        print(message.event, message.dispatch)\n    ```\n\n    Args:\n        microgrid_id: The microgrid_id to receive dispatches for.\n\n    Returns:\n        A receiver channel to receive the stream of dispatch events.\n    \"\"\"\n    return self._get_stream(microgrid_id).new_receiver()\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient.update","title":"update  <code>async</code>","text":"<pre><code>update(\n    *,\n    microgrid_id: int,\n    dispatch_id: int,\n    new_fields: dict[str, Any]\n) -&gt; Dispatch\n</code></pre> <p>Update a dispatch.</p> <p>The <code>new_fields</code> argument is a dictionary of fields to update. The keys are the field names, and the values are the new values for the fields.</p> <p>For recurrence fields, the keys are preceeded by \"recurrence.\".</p> <p>Note that updating <code>type</code> and <code>dry_run</code> is not supported.</p> PARAMETER DESCRIPTION <code>microgrid_id</code> <p>The microgrid_id to update the dispatch for.</p> <p> TYPE: <code>int</code> </p> <code>dispatch_id</code> <p>The dispatch_id to update.</p> <p> TYPE: <code>int</code> </p> <code>new_fields</code> <p>The fields to update.</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>Dispatch</code> <p>The updated dispatch.</p> <p> TYPE: <code>Dispatch</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If updating <code>type</code> or <code>dry_run</code>.</p> Source code in <code>frequenz/client/dispatch/_client.py</code> <pre><code>async def update(\n    self,\n    *,\n    microgrid_id: int,\n    dispatch_id: int,\n    new_fields: dict[str, Any],\n) -&gt; Dispatch:\n    \"\"\"Update a dispatch.\n\n    The `new_fields` argument is a dictionary of fields to update. The keys are\n    the field names, and the values are the new values for the fields.\n\n    For recurrence fields, the keys are preceeded by \"recurrence.\".\n\n    Note that updating `type` and `dry_run` is not supported.\n\n    Args:\n        microgrid_id: The microgrid_id to update the dispatch for.\n        dispatch_id: The dispatch_id to update.\n        new_fields: The fields to update.\n\n    Returns:\n        Dispatch: The updated dispatch.\n\n    Raises:\n        ValueError: If updating `type` or `dry_run`.\n    \"\"\"\n    msg = UpdateMicrogridDispatchRequest(\n        dispatch_id=dispatch_id, microgrid_id=microgrid_id\n    )\n\n    for key, val in new_fields.items():\n        path = key.split(\".\")\n\n        match path[0]:\n            case \"start_time\":\n                msg.update.start_time.CopyFrom(to_timestamp(val))\n            case \"duration\":\n                if val is None:\n                    msg.update.ClearField(\"duration\")\n                else:\n                    msg.update.duration = round(val.total_seconds())\n            case \"selector\":\n                msg.update.selector.CopyFrom(component_selector_to_protobuf(val))\n            case \"is_active\":\n                msg.update.is_active = val\n            case \"payload\":\n                msg.update.payload.update(val)\n            case \"active\":\n                msg.update.is_active = val\n                key = \"is_active\"\n            case \"recurrence\":\n                match path[1]:\n                    case \"freq\":\n                        msg.update.recurrence.freq = val\n                    # Proto uses \"freq\" instead of \"frequency\"\n                    case \"frequency\":\n                        msg.update.recurrence.freq = val\n                        # Correct the key to \"recurrence.freq\"\n                        key = \"recurrence.freq\"\n                    case \"interval\":\n                        msg.update.recurrence.interval = val\n                    case \"end_criteria\":\n                        msg.update.recurrence.end_criteria.CopyFrom(\n                            val.to_protobuf()\n                        )\n                    case \"byminutes\":\n                        msg.update.recurrence.byminutes.extend(val)\n                    case \"byhours\":\n                        msg.update.recurrence.byhours.extend(val)\n                    case \"byweekdays\":\n                        msg.update.recurrence.byweekdays.extend(val)\n                    case \"bymonthdays\":\n                        msg.update.recurrence.bymonthdays.extend(val)\n                    case \"bymonths\":\n                        msg.update.recurrence.bymonths.extend(val)\n                    case _:\n                        raise ValueError(f\"Unknown recurrence field: {path[1]}\")\n            case _:\n                raise ValueError(f\"Unknown field: {path[0]}\")\n\n        msg.update_mask.paths.append(key)\n\n    response = await cast(\n        Awaitable[UpdateMicrogridDispatchResponse],\n        self.stub.UpdateMicrogridDispatch(msg, metadata=self._metadata),\n    )\n\n    return Dispatch.from_protobuf(response.dispatch)\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.to_create_params","title":"frequenz.client.dispatch.test.client.to_create_params","text":"<pre><code>to_create_params(\n    microgrid_id: int, dispatch: Dispatch\n) -&gt; dict[str, Any]\n</code></pre> <p>Convert a dispatch to client.create parameters.</p> PARAMETER DESCRIPTION <code>microgrid_id</code> <p>The microgrid id.</p> <p> TYPE: <code>int</code> </p> <code>dispatch</code> <p>The dispatch to convert.</p> <p> TYPE: <code>Dispatch</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>dict[str, Any]: The create parameters.</p> Source code in <code>frequenz/client/dispatch/test/client.py</code> <pre><code>def to_create_params(microgrid_id: int, dispatch: Dispatch) -&gt; dict[str, Any]:\n    \"\"\"Convert a dispatch to client.create parameters.\n\n    Args:\n        microgrid_id: The microgrid id.\n        dispatch: The dispatch to convert.\n\n    Returns:\n        dict[str, Any]: The create parameters.\n    \"\"\"\n    return {\n        \"microgrid_id\": microgrid_id,\n        \"type\": dispatch.type,\n        \"start_time\": dispatch.start_time,\n        \"duration\": dispatch.duration,\n        \"selector\": dispatch.selector,\n        \"active\": dispatch.active,\n        \"dry_run\": dispatch.dry_run,\n        \"payload\": dispatch.payload,\n        \"recurrence\": dispatch.recurrence,\n    }\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/fixtures/","title":"fixtures","text":""},{"location":"reference/frequenz/client/dispatch/test/fixtures/#frequenz.client.dispatch.test.fixtures","title":"frequenz.client.dispatch.test.fixtures","text":"<p>Useful fixtures for testing.</p>"},{"location":"reference/frequenz/client/dispatch/test/fixtures/#frequenz.client.dispatch.test.fixtures-classes","title":"Classes","text":""},{"location":"reference/frequenz/client/dispatch/test/fixtures/#frequenz.client.dispatch.test.fixtures-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/dispatch/test/fixtures/#frequenz.client.dispatch.test.fixtures.client","title":"frequenz.client.dispatch.test.fixtures.client","text":"<pre><code>client() -&gt; FakeClient\n</code></pre> <p>Return a fake client.</p> Source code in <code>frequenz/client/dispatch/test/fixtures.py</code> <pre><code>@fixture\ndef client() -&gt; FakeClient:\n    \"\"\"Return a fake client.\"\"\"\n    return FakeClient()\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/fixtures/#frequenz.client.dispatch.test.fixtures.generator","title":"frequenz.client.dispatch.test.fixtures.generator","text":"<pre><code>generator() -&gt; DispatchGenerator\n</code></pre> <p>Return a dispatch generator.</p> Source code in <code>frequenz/client/dispatch/test/fixtures.py</code> <pre><code>@fixture\ndef generator() -&gt; DispatchGenerator:\n    \"\"\"Return a dispatch generator.\"\"\"\n    return DispatchGenerator()\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/fixtures/#frequenz.client.dispatch.test.fixtures.sample","title":"frequenz.client.dispatch.test.fixtures.sample","text":"<pre><code>sample(generator: DispatchGenerator) -&gt; Dispatch\n</code></pre> <p>Return a dispatch sample.</p> Source code in <code>frequenz/client/dispatch/test/fixtures.py</code> <pre><code>@fixture\ndef sample(generator: DispatchGenerator) -&gt; Dispatch:\n    \"\"\"Return a dispatch sample.\"\"\"\n    return generator.generate_dispatch()\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/generator/","title":"generator","text":""},{"location":"reference/frequenz/client/dispatch/test/generator/#frequenz.client.dispatch.test.generator","title":"frequenz.client.dispatch.test.generator","text":"<p>A sampler for dispatch messages.</p>"},{"location":"reference/frequenz/client/dispatch/test/generator/#frequenz.client.dispatch.test.generator-classes","title":"Classes","text":""},{"location":"reference/frequenz/client/dispatch/test/generator/#frequenz.client.dispatch.test.generator.DispatchGenerator","title":"frequenz.client.dispatch.test.generator.DispatchGenerator","text":"<p>Generates random dispatch messages.</p> Source code in <code>frequenz/client/dispatch/test/generator.py</code> <pre><code>class DispatchGenerator:\n    \"\"\"Generates random dispatch messages.\"\"\"\n\n    def __init__(self, seed: int = 0) -&gt; None:\n        \"\"\"Initialize the sampler.\n\n        Args:\n            seed: seed to initialize the rng with\n        \"\"\"\n        self._rng = random.Random(seed)\n        self._last_id: int = 0\n\n    def generate_recurrence_rule(self) -&gt; RecurrenceRule:\n        \"\"\"Generate a random recurrence rule.\n\n        Returns:\n            a random recurrence rule\n        \"\"\"\n        return RecurrenceRule(\n            frequency=self._rng.choice(list(Frequency)[1:]),\n            interval=self._rng.randint(1, 100),\n            end_criteria=self._rng.choice(\n                [\n                    None,\n                    self._rng.choice(\n                        [\n                            EndCriteria(count=self._rng.randint(1, 1000)),\n                            EndCriteria(\n                                until=datetime.fromtimestamp(\n                                    self._rng.randint(0, 1000000),\n                                    tz=timezone.utc,\n                                )\n                            ),\n                        ]\n                    ),\n                ]\n            ),\n            byminutes=[\n                self._rng.randint(0, 59) for _ in range(self._rng.randint(0, 10))\n            ],\n            byhours=[self._rng.randint(0, 23) for _ in range(self._rng.randint(0, 10))],\n            byweekdays=[\n                self._rng.choice(list(Weekday)[1:])\n                for _ in range(self._rng.randint(0, 7))\n            ],\n            bymonthdays=[\n                self._rng.randint(1, 31) for _ in range(self._rng.randint(0, 10))\n            ],\n            bymonths=[\n                self._rng.randint(1, 12) for _ in range(self._rng.randint(0, 12))\n            ],\n        )\n\n    def generate_dispatch(self) -&gt; Dispatch:\n        \"\"\"Generate a random dispatch instance.\n\n        Returns:\n            a random dispatch instance\n        \"\"\"\n        self._last_id += 1\n        create_time = datetime.fromtimestamp(\n            self._rng.randint(0, 1000000), tz=timezone.utc\n        )\n\n        return Dispatch(\n            id=self._last_id,\n            create_time=create_time,\n            update_time=create_time + timedelta(seconds=self._rng.randint(0, 1000000)),\n            type=str(self._rng.randint(0, 100_000)),\n            start_time=rounded_start_time(\n                datetime.now(tz=timezone.utc)\n                + timedelta(seconds=self._rng.randint(0, 1000000))\n            ),\n            duration=self._rng.choice(\n                [\n                    None,\n                    timedelta(seconds=self._rng.randint(0, 1000000)),\n                ]\n            ),\n            selector=self._rng.choice(  # type: ignore\n                [\n                    [\n                        self._rng.choice(list(ComponentCategory)[1:])\n                        for _ in range(self._rng.randint(1, 10))\n                    ],\n                    [\n                        self._rng.randint(1, 100)\n                        for _ in range(self._rng.randint(1, 10))\n                    ],\n                ]\n            ),\n            active=self._rng.choice([True, False]),\n            dry_run=self._rng.choice([True, False]),\n            payload={\n                f\"key_{i}\": self._rng.choice(\n                    [\n                        self._rng.randint(0, 100),\n                        self._rng.uniform(0, 100),\n                        self._rng.choice([True, False]),\n                        self._rng.choice([\"a\", \"b\", \"c\"]),\n                    ]\n                )\n                for i in range(self._rng.randint(0, 10))\n            },\n            recurrence=self.generate_recurrence_rule(),\n        )\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/generator/#frequenz.client.dispatch.test.generator.DispatchGenerator-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/dispatch/test/generator/#frequenz.client.dispatch.test.generator.DispatchGenerator.__init__","title":"__init__","text":"<pre><code>__init__(seed: int = 0) -&gt; None\n</code></pre> <p>Initialize the sampler.</p> PARAMETER DESCRIPTION <code>seed</code> <p>seed to initialize the rng with</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/client/dispatch/test/generator.py</code> <pre><code>def __init__(self, seed: int = 0) -&gt; None:\n    \"\"\"Initialize the sampler.\n\n    Args:\n        seed: seed to initialize the rng with\n    \"\"\"\n    self._rng = random.Random(seed)\n    self._last_id: int = 0\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/generator/#frequenz.client.dispatch.test.generator.DispatchGenerator.generate_dispatch","title":"generate_dispatch","text":"<pre><code>generate_dispatch() -&gt; Dispatch\n</code></pre> <p>Generate a random dispatch instance.</p> RETURNS DESCRIPTION <code>Dispatch</code> <p>a random dispatch instance</p> Source code in <code>frequenz/client/dispatch/test/generator.py</code> <pre><code>def generate_dispatch(self) -&gt; Dispatch:\n    \"\"\"Generate a random dispatch instance.\n\n    Returns:\n        a random dispatch instance\n    \"\"\"\n    self._last_id += 1\n    create_time = datetime.fromtimestamp(\n        self._rng.randint(0, 1000000), tz=timezone.utc\n    )\n\n    return Dispatch(\n        id=self._last_id,\n        create_time=create_time,\n        update_time=create_time + timedelta(seconds=self._rng.randint(0, 1000000)),\n        type=str(self._rng.randint(0, 100_000)),\n        start_time=rounded_start_time(\n            datetime.now(tz=timezone.utc)\n            + timedelta(seconds=self._rng.randint(0, 1000000))\n        ),\n        duration=self._rng.choice(\n            [\n                None,\n                timedelta(seconds=self._rng.randint(0, 1000000)),\n            ]\n        ),\n        selector=self._rng.choice(  # type: ignore\n            [\n                [\n                    self._rng.choice(list(ComponentCategory)[1:])\n                    for _ in range(self._rng.randint(1, 10))\n                ],\n                [\n                    self._rng.randint(1, 100)\n                    for _ in range(self._rng.randint(1, 10))\n                ],\n            ]\n        ),\n        active=self._rng.choice([True, False]),\n        dry_run=self._rng.choice([True, False]),\n        payload={\n            f\"key_{i}\": self._rng.choice(\n                [\n                    self._rng.randint(0, 100),\n                    self._rng.uniform(0, 100),\n                    self._rng.choice([True, False]),\n                    self._rng.choice([\"a\", \"b\", \"c\"]),\n                ]\n            )\n            for i in range(self._rng.randint(0, 10))\n        },\n        recurrence=self.generate_recurrence_rule(),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/generator/#frequenz.client.dispatch.test.generator.DispatchGenerator.generate_recurrence_rule","title":"generate_recurrence_rule","text":"<pre><code>generate_recurrence_rule() -&gt; RecurrenceRule\n</code></pre> <p>Generate a random recurrence rule.</p> RETURNS DESCRIPTION <code>RecurrenceRule</code> <p>a random recurrence rule</p> Source code in <code>frequenz/client/dispatch/test/generator.py</code> <pre><code>def generate_recurrence_rule(self) -&gt; RecurrenceRule:\n    \"\"\"Generate a random recurrence rule.\n\n    Returns:\n        a random recurrence rule\n    \"\"\"\n    return RecurrenceRule(\n        frequency=self._rng.choice(list(Frequency)[1:]),\n        interval=self._rng.randint(1, 100),\n        end_criteria=self._rng.choice(\n            [\n                None,\n                self._rng.choice(\n                    [\n                        EndCriteria(count=self._rng.randint(1, 1000)),\n                        EndCriteria(\n                            until=datetime.fromtimestamp(\n                                self._rng.randint(0, 1000000),\n                                tz=timezone.utc,\n                            )\n                        ),\n                    ]\n                ),\n            ]\n        ),\n        byminutes=[\n            self._rng.randint(0, 59) for _ in range(self._rng.randint(0, 10))\n        ],\n        byhours=[self._rng.randint(0, 23) for _ in range(self._rng.randint(0, 10))],\n        byweekdays=[\n            self._rng.choice(list(Weekday)[1:])\n            for _ in range(self._rng.randint(0, 7))\n        ],\n        bymonthdays=[\n            self._rng.randint(1, 31) for _ in range(self._rng.randint(0, 10))\n        ],\n        bymonths=[\n            self._rng.randint(1, 12) for _ in range(self._rng.randint(0, 12))\n        ],\n    )\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/generator/#frequenz.client.dispatch.test.generator-functions","title":"Functions","text":""}]}