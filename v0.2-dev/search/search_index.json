{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Dispatch Client Library","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Dispatch API client for Python</p>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<p>The following platforms are officially supported (tested):</p> <ul> <li>Python: 3.11</li> <li>Operating System: Ubuntu Linux 20.04</li> <li>Architectures: amd64, arm64</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz Dispatch Client Library","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>client<ul> <li>dispatch<ul> <li>test<ul> <li>client</li> <li>generator</li> </ul> </li> <li>types</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/frequenz/client/dispatch/","title":"Index","text":""},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch","title":"frequenz.client.dispatch","text":"<p>Dispatch API client for Python.</p>"},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch-classes","title":"Classes","text":""},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch.Client","title":"frequenz.client.dispatch.Client","text":"<p>Dispatch API client.</p> Source code in <code>frequenz/client/dispatch/_client.py</code> <pre><code>class Client:\n    \"\"\"Dispatch API client.\"\"\"\n\n    def __init__(self, grpc_channel: grpc.aio.Channel, svc_addr: str) -&gt; None:\n        \"\"\"Initialize the client.\n\n        Args:\n            grpc_channel: gRPC channel to use for communication with the API.\n            svc_addr: Address of the service to connect to.\n        \"\"\"\n        self._svc_addr = svc_addr\n        self._stub = dispatch_pb2_grpc.MicrogridDispatchServiceStub(grpc_channel)\n\n    # pylint: disable=too-many-arguments, too-many-locals\n    async def list(\n        self,\n        microgrid_id: int,\n        component_selectors: Iterator[ComponentSelector] = iter(()),\n        start_from: datetime | None = None,\n        start_to: datetime | None = None,\n        end_from: datetime | None = None,\n        end_to: datetime | None = None,\n        active: bool | None = None,\n        dry_run: bool | None = None,\n    ) -&gt; AsyncIterator[Dispatch]:\n        \"\"\"List dispatches.\n\n        Example usage:\n\n        ```python\n        grpc_channel = grpc.aio.insecure_channel(\"example\")\n        client = Client(grpc_channel, \"localhost:50051\")\n        async for dispatch in client.list(microgrid_id=1):\n            print(dispatch)\n        ```\n\n        Yields:\n            Dispatch: The dispatches.\n\n        Args:\n            microgrid_id: The microgrid_id to list dispatches for.\n            component_selectors: optional, list of component ids or categories to filter by.\n            start_from: optional, filter by start_time &gt;= start_from.\n            start_to: optional, filter by start_time &lt; start_to.\n            end_from: optional, filter by end_time &gt;= end_from.\n            end_to: optional, filter by end_time &lt; end_to.\n            active: optional, filter by active status.\n            dry_run: optional, filter by dry_run status.\n\n        Returns:\n            An async iterator of dispatches.\n        \"\"\"\n        time_interval = None\n\n        def to_timestamp(dt: datetime | None) -&gt; Timestamp | None:\n            if dt is None:\n                return None\n\n            ts = Timestamp()\n            ts.FromDatetime(dt)\n            return ts\n\n        if start_from or start_to or end_from or end_to:\n            time_interval = PBTimeIntervalFilter(\n                start_from=to_timestamp(start_from),\n                start_to=to_timestamp(start_to),\n                end_from=to_timestamp(end_from),\n                end_to=to_timestamp(end_to),\n            )\n\n        selectors = []\n\n        for selector in component_selectors:\n            selectors.append(component_selector_to_protobuf(selector))\n\n        filters = DispatchFilter(\n            selectors=selectors,\n            time_interval=time_interval,\n            is_active=active,\n            is_dry_run=dry_run,\n        )\n        request = DispatchListRequest(microgrid_id=microgrid_id, filter=filters)\n\n        response = await self._stub.ListMicrogridDispatches(request)  # type: ignore\n        for dispatch in response.dispatches:\n            yield Dispatch.from_protobuf(dispatch)\n\n    async def create(\n        self,\n        microgrid_id: int,\n        _type: str,\n        start_time: datetime,\n        duration: timedelta,\n        selector: ComponentSelector,\n        active: bool = True,\n        dry_run: bool = False,\n        payload: dict[str, Any] | None = None,\n        recurrence: RecurrenceRule | None = None,\n    ) -&gt; None:\n        \"\"\"Create a dispatch.\n\n        Args:\n            microgrid_id: The microgrid_id to create the dispatch for.\n            _type: User defined string to identify the dispatch type.\n            start_time: The start time of the dispatch.\n            duration: The duration of the dispatch.\n            selector: The component selector for the dispatch.\n            active: The active status of the dispatch.\n            dry_run: The dry_run status of the dispatch.\n            payload: The payload of the dispatch.\n            recurrence: The recurrence rule of the dispatch.\n\n        Raises:\n            ValueError: If start_time is in the past.\n        \"\"\"\n        if start_time &lt;= datetime.now().astimezone(start_time.tzinfo):\n            raise ValueError(\"start_time must not be in the past\")\n\n        request = DispatchCreateRequest(\n            microgrid_id=microgrid_id,\n            type=_type,\n            start_time=start_time,\n            duration=duration,\n            selector=selector,\n            is_active=active,\n            is_dry_run=dry_run,\n            payload=payload or {},\n            recurrence=recurrence or RecurrenceRule(),\n        ).to_protobuf()\n\n        await self._stub.CreateMicrogridDispatch(request)  # type: ignore\n\n    async def update(\n        self,\n        *,\n        dispatch_id: int,\n        new_fields: dict[str, Any],\n    ) -&gt; None:\n        \"\"\"Update a dispatch.\n\n        The `new_fields` argument is a dictionary of fields to update. The keys are\n        the field names, and the values are the new values for the fields.\n\n        For recurrence fields, the keys are preceeded by \"recurrence.\".\n\n        Args:\n            dispatch_id: The dispatch_id to update.\n            new_fields: The fields to update.\n        \"\"\"\n        msg = DispatchUpdateRequest(id=dispatch_id)\n\n        for key, val in new_fields.items():\n            path = key.split(\".\")\n\n            match path[0]:\n                case \"type\":\n                    msg.update.type = val\n                case \"start_time\":\n                    msg.update.start_time.FromDatetime(val)\n                case \"duration\":\n                    msg.update.duration = int(val.total_seconds())\n                case \"selector\":\n                    msg.update.selector.CopyFrom(component_selector_to_protobuf(val))\n                case \"is_active\":\n                    msg.update.is_active = val\n                case \"active\":\n                    msg.update.is_active = val\n                    key = \"is_active\"\n                case \"is_dry_run\":\n                    msg.update.is_dry_run = val\n                case \"dry_run\":\n                    msg.update.is_dry_run = val\n                    key = \"is_dry_run\"\n                case \"recurrence\":\n                    match path[1]:\n                        case \"freq\":\n                            msg.update.recurrence.freq = val\n                        # Proto uses \"freq\" instead of \"frequency\"\n                        case \"frequency\":\n                            msg.update.recurrence.freq = val\n                            # Correct the key to \"recurrence.freq\"\n                            key = \"recurrence.freq\"\n                        case \"interval\":\n                            msg.update.recurrence.interval = val\n                        case \"end_criteria\":\n                            msg.update.recurrence.end_criteria.CopyFrom(\n                                val.to_protobuf()\n                            )\n                        case \"byminutes\":\n                            msg.update.recurrence.byminutes.extend(val)\n                        case \"byhours\":\n                            msg.update.recurrence.byhours.extend(val)\n                        case \"byweekdays\":\n                            msg.update.recurrence.byweekdays.extend(val)\n                        case \"bymonthdays\":\n                            msg.update.recurrence.bymonthdays.extend(val)\n                        case \"bymonths\":\n                            msg.update.recurrence.bymonths.extend(val)\n\n            msg.update_mask.paths.append(key)\n\n        await self._stub.UpdateMicrogridDispatch(msg)  # type: ignore\n\n    async def get(self, dispatch_id: int) -&gt; Dispatch:\n        \"\"\"Get a dispatch.\n\n        Args:\n            dispatch_id: The dispatch_id to get.\n\n        Returns:\n            Dispatch: The dispatch.\n        \"\"\"\n        request = DispatchGetRequest(id=dispatch_id)\n        response = await self._stub.GetMicrogridDispatch(request)  # type: ignore\n        return Dispatch.from_protobuf(response)\n\n    async def delete(self, dispatch_id: int) -&gt; None:\n        \"\"\"Delete a dispatch.\n\n        Args:\n            dispatch_id: The dispatch_id to delete.\n        \"\"\"\n        request = DispatchDeleteRequest(id=dispatch_id)\n        await self._stub.DeleteMicrogridDispatch(request)  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch.Client-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch.Client.__init__","title":"__init__","text":"<pre><code>__init__(grpc_channel: Channel, svc_addr: str) -&gt; None\n</code></pre> <p>Initialize the client.</p> PARAMETER  DESCRIPTION <code>grpc_channel</code> <p>gRPC channel to use for communication with the API.</p> <p> TYPE: <code>Channel</code> </p> <code>svc_addr</code> <p>Address of the service to connect to.</p> <p> TYPE: <code>str</code> </p> Source code in <code>frequenz/client/dispatch/_client.py</code> <pre><code>def __init__(self, grpc_channel: grpc.aio.Channel, svc_addr: str) -&gt; None:\n    \"\"\"Initialize the client.\n\n    Args:\n        grpc_channel: gRPC channel to use for communication with the API.\n        svc_addr: Address of the service to connect to.\n    \"\"\"\n    self._svc_addr = svc_addr\n    self._stub = dispatch_pb2_grpc.MicrogridDispatchServiceStub(grpc_channel)\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch.Client.create","title":"create  <code>async</code>","text":"<pre><code>create(\n    microgrid_id: int,\n    _type: str,\n    start_time: datetime,\n    duration: timedelta,\n    selector: ComponentSelector,\n    active: bool = True,\n    dry_run: bool = False,\n    payload: dict[str, Any] | None = None,\n    recurrence: RecurrenceRule | None = None,\n) -&gt; None\n</code></pre> <p>Create a dispatch.</p> PARAMETER  DESCRIPTION <code>microgrid_id</code> <p>The microgrid_id to create the dispatch for.</p> <p> TYPE: <code>int</code> </p> <code>_type</code> <p>User defined string to identify the dispatch type.</p> <p> TYPE: <code>str</code> </p> <code>start_time</code> <p>The start time of the dispatch.</p> <p> TYPE: <code>datetime</code> </p> <code>duration</code> <p>The duration of the dispatch.</p> <p> TYPE: <code>timedelta</code> </p> <code>selector</code> <p>The component selector for the dispatch.</p> <p> TYPE: <code>ComponentSelector</code> </p> <code>active</code> <p>The active status of the dispatch.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>dry_run</code> <p>The dry_run status of the dispatch.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>payload</code> <p>The payload of the dispatch.</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>recurrence</code> <p>The recurrence rule of the dispatch.</p> <p> TYPE: <code>RecurrenceRule | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If start_time is in the past.</p> Source code in <code>frequenz/client/dispatch/_client.py</code> <pre><code>async def create(\n    self,\n    microgrid_id: int,\n    _type: str,\n    start_time: datetime,\n    duration: timedelta,\n    selector: ComponentSelector,\n    active: bool = True,\n    dry_run: bool = False,\n    payload: dict[str, Any] | None = None,\n    recurrence: RecurrenceRule | None = None,\n) -&gt; None:\n    \"\"\"Create a dispatch.\n\n    Args:\n        microgrid_id: The microgrid_id to create the dispatch for.\n        _type: User defined string to identify the dispatch type.\n        start_time: The start time of the dispatch.\n        duration: The duration of the dispatch.\n        selector: The component selector for the dispatch.\n        active: The active status of the dispatch.\n        dry_run: The dry_run status of the dispatch.\n        payload: The payload of the dispatch.\n        recurrence: The recurrence rule of the dispatch.\n\n    Raises:\n        ValueError: If start_time is in the past.\n    \"\"\"\n    if start_time &lt;= datetime.now().astimezone(start_time.tzinfo):\n        raise ValueError(\"start_time must not be in the past\")\n\n    request = DispatchCreateRequest(\n        microgrid_id=microgrid_id,\n        type=_type,\n        start_time=start_time,\n        duration=duration,\n        selector=selector,\n        is_active=active,\n        is_dry_run=dry_run,\n        payload=payload or {},\n        recurrence=recurrence or RecurrenceRule(),\n    ).to_protobuf()\n\n    await self._stub.CreateMicrogridDispatch(request)  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch.Client.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(dispatch_id: int) -&gt; None\n</code></pre> <p>Delete a dispatch.</p> PARAMETER  DESCRIPTION <code>dispatch_id</code> <p>The dispatch_id to delete.</p> <p> TYPE: <code>int</code> </p> Source code in <code>frequenz/client/dispatch/_client.py</code> <pre><code>async def delete(self, dispatch_id: int) -&gt; None:\n    \"\"\"Delete a dispatch.\n\n    Args:\n        dispatch_id: The dispatch_id to delete.\n    \"\"\"\n    request = DispatchDeleteRequest(id=dispatch_id)\n    await self._stub.DeleteMicrogridDispatch(request)  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch.Client.get","title":"get  <code>async</code>","text":"<pre><code>get(dispatch_id: int) -&gt; Dispatch\n</code></pre> <p>Get a dispatch.</p> PARAMETER  DESCRIPTION <code>dispatch_id</code> <p>The dispatch_id to get.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Dispatch</code> <p>The dispatch.</p> <p> TYPE: <code>Dispatch</code> </p> Source code in <code>frequenz/client/dispatch/_client.py</code> <pre><code>async def get(self, dispatch_id: int) -&gt; Dispatch:\n    \"\"\"Get a dispatch.\n\n    Args:\n        dispatch_id: The dispatch_id to get.\n\n    Returns:\n        Dispatch: The dispatch.\n    \"\"\"\n    request = DispatchGetRequest(id=dispatch_id)\n    response = await self._stub.GetMicrogridDispatch(request)  # type: ignore\n    return Dispatch.from_protobuf(response)\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch.Client.list","title":"list  <code>async</code>","text":"<pre><code>list(\n    microgrid_id: int,\n    component_selectors: Iterator[ComponentSelector] = iter(\n        ()\n    ),\n    start_from: datetime | None = None,\n    start_to: datetime | None = None,\n    end_from: datetime | None = None,\n    end_to: datetime | None = None,\n    active: bool | None = None,\n    dry_run: bool | None = None,\n) -&gt; AsyncIterator[Dispatch]\n</code></pre> <p>List dispatches.</p> <p>Example usage:</p> <pre><code>grpc_channel = grpc.aio.insecure_channel(\"example\")\nclient = Client(grpc_channel, \"localhost:50051\")\nasync for dispatch in client.list(microgrid_id=1):\n    print(dispatch)\n</code></pre> YIELDS DESCRIPTION <code>Dispatch</code> <p>The dispatches.</p> <p> TYPE:: <code>AsyncIterator[Dispatch]</code> </p> PARAMETER  DESCRIPTION <code>microgrid_id</code> <p>The microgrid_id to list dispatches for.</p> <p> TYPE: <code>int</code> </p> <code>component_selectors</code> <p>optional, list of component ids or categories to filter by.</p> <p> TYPE: <code>Iterator[ComponentSelector]</code> DEFAULT: <code>iter(())</code> </p> <code>start_from</code> <p>optional, filter by start_time &gt;= start_from.</p> <p> TYPE: <code>datetime | None</code> DEFAULT: <code>None</code> </p> <code>start_to</code> <p>optional, filter by start_time &lt; start_to.</p> <p> TYPE: <code>datetime | None</code> DEFAULT: <code>None</code> </p> <code>end_from</code> <p>optional, filter by end_time &gt;= end_from.</p> <p> TYPE: <code>datetime | None</code> DEFAULT: <code>None</code> </p> <code>end_to</code> <p>optional, filter by end_time &lt; end_to.</p> <p> TYPE: <code>datetime | None</code> DEFAULT: <code>None</code> </p> <code>active</code> <p>optional, filter by active status.</p> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> <code>dry_run</code> <p>optional, filter by dry_run status.</p> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>AsyncIterator[Dispatch]</code> <p>An async iterator of dispatches.</p> Source code in <code>frequenz/client/dispatch/_client.py</code> <pre><code>async def list(\n    self,\n    microgrid_id: int,\n    component_selectors: Iterator[ComponentSelector] = iter(()),\n    start_from: datetime | None = None,\n    start_to: datetime | None = None,\n    end_from: datetime | None = None,\n    end_to: datetime | None = None,\n    active: bool | None = None,\n    dry_run: bool | None = None,\n) -&gt; AsyncIterator[Dispatch]:\n    \"\"\"List dispatches.\n\n    Example usage:\n\n    ```python\n    grpc_channel = grpc.aio.insecure_channel(\"example\")\n    client = Client(grpc_channel, \"localhost:50051\")\n    async for dispatch in client.list(microgrid_id=1):\n        print(dispatch)\n    ```\n\n    Yields:\n        Dispatch: The dispatches.\n\n    Args:\n        microgrid_id: The microgrid_id to list dispatches for.\n        component_selectors: optional, list of component ids or categories to filter by.\n        start_from: optional, filter by start_time &gt;= start_from.\n        start_to: optional, filter by start_time &lt; start_to.\n        end_from: optional, filter by end_time &gt;= end_from.\n        end_to: optional, filter by end_time &lt; end_to.\n        active: optional, filter by active status.\n        dry_run: optional, filter by dry_run status.\n\n    Returns:\n        An async iterator of dispatches.\n    \"\"\"\n    time_interval = None\n\n    def to_timestamp(dt: datetime | None) -&gt; Timestamp | None:\n        if dt is None:\n            return None\n\n        ts = Timestamp()\n        ts.FromDatetime(dt)\n        return ts\n\n    if start_from or start_to or end_from or end_to:\n        time_interval = PBTimeIntervalFilter(\n            start_from=to_timestamp(start_from),\n            start_to=to_timestamp(start_to),\n            end_from=to_timestamp(end_from),\n            end_to=to_timestamp(end_to),\n        )\n\n    selectors = []\n\n    for selector in component_selectors:\n        selectors.append(component_selector_to_protobuf(selector))\n\n    filters = DispatchFilter(\n        selectors=selectors,\n        time_interval=time_interval,\n        is_active=active,\n        is_dry_run=dry_run,\n    )\n    request = DispatchListRequest(microgrid_id=microgrid_id, filter=filters)\n\n    response = await self._stub.ListMicrogridDispatches(request)  # type: ignore\n    for dispatch in response.dispatches:\n        yield Dispatch.from_protobuf(dispatch)\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/#frequenz.client.dispatch.Client.update","title":"update  <code>async</code>","text":"<pre><code>update(\n    *, dispatch_id: int, new_fields: dict[str, Any]\n) -&gt; None\n</code></pre> <p>Update a dispatch.</p> <p>The <code>new_fields</code> argument is a dictionary of fields to update. The keys are the field names, and the values are the new values for the fields.</p> <p>For recurrence fields, the keys are preceeded by \"recurrence.\".</p> PARAMETER  DESCRIPTION <code>dispatch_id</code> <p>The dispatch_id to update.</p> <p> TYPE: <code>int</code> </p> <code>new_fields</code> <p>The fields to update.</p> <p> TYPE: <code>dict[str, Any]</code> </p> Source code in <code>frequenz/client/dispatch/_client.py</code> <pre><code>async def update(\n    self,\n    *,\n    dispatch_id: int,\n    new_fields: dict[str, Any],\n) -&gt; None:\n    \"\"\"Update a dispatch.\n\n    The `new_fields` argument is a dictionary of fields to update. The keys are\n    the field names, and the values are the new values for the fields.\n\n    For recurrence fields, the keys are preceeded by \"recurrence.\".\n\n    Args:\n        dispatch_id: The dispatch_id to update.\n        new_fields: The fields to update.\n    \"\"\"\n    msg = DispatchUpdateRequest(id=dispatch_id)\n\n    for key, val in new_fields.items():\n        path = key.split(\".\")\n\n        match path[0]:\n            case \"type\":\n                msg.update.type = val\n            case \"start_time\":\n                msg.update.start_time.FromDatetime(val)\n            case \"duration\":\n                msg.update.duration = int(val.total_seconds())\n            case \"selector\":\n                msg.update.selector.CopyFrom(component_selector_to_protobuf(val))\n            case \"is_active\":\n                msg.update.is_active = val\n            case \"active\":\n                msg.update.is_active = val\n                key = \"is_active\"\n            case \"is_dry_run\":\n                msg.update.is_dry_run = val\n            case \"dry_run\":\n                msg.update.is_dry_run = val\n                key = \"is_dry_run\"\n            case \"recurrence\":\n                match path[1]:\n                    case \"freq\":\n                        msg.update.recurrence.freq = val\n                    # Proto uses \"freq\" instead of \"frequency\"\n                    case \"frequency\":\n                        msg.update.recurrence.freq = val\n                        # Correct the key to \"recurrence.freq\"\n                        key = \"recurrence.freq\"\n                    case \"interval\":\n                        msg.update.recurrence.interval = val\n                    case \"end_criteria\":\n                        msg.update.recurrence.end_criteria.CopyFrom(\n                            val.to_protobuf()\n                        )\n                    case \"byminutes\":\n                        msg.update.recurrence.byminutes.extend(val)\n                    case \"byhours\":\n                        msg.update.recurrence.byhours.extend(val)\n                    case \"byweekdays\":\n                        msg.update.recurrence.byweekdays.extend(val)\n                    case \"bymonthdays\":\n                        msg.update.recurrence.bymonthdays.extend(val)\n                    case \"bymonths\":\n                        msg.update.recurrence.bymonths.extend(val)\n\n        msg.update_mask.paths.append(key)\n\n    await self._stub.UpdateMicrogridDispatch(msg)  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/","title":"types","text":""},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types","title":"frequenz.client.dispatch.types","text":"<p>Type wrappers for the generated protobuf messages.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.ComponentSelector","title":"frequenz.client.dispatch.types.ComponentSelector  <code>module-attribute</code>","text":"<pre><code>ComponentSelector = list[int] | ComponentCategory\n</code></pre> <p>A component selector specifying which components a dispatch targets.</p> <p>A component selector can be a list of component IDs or a component category.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types-classes","title":"Classes","text":""},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch","title":"frequenz.client.dispatch.types.Dispatch  <code>dataclass</code>","text":"<p>Represents a dispatch operation within a microgrid system.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>@dataclass(kw_only=True, frozen=True)\nclass Dispatch:\n    \"\"\"Represents a dispatch operation within a microgrid system.\"\"\"\n\n    id: int\n    \"\"\"The unique identifier for the dispatch.\"\"\"\n\n    microgrid_id: int\n    \"\"\"The identifier of the microgrid to which this dispatch belongs.\"\"\"\n\n    type: str\n    \"\"\"User-defined information about the type of dispatch.\n\n    This is understood and processed by downstream applications.\"\"\"\n\n    start_time: datetime\n    \"\"\"The start time of the dispatch in UTC.\"\"\"\n\n    duration: timedelta\n    \"\"\"The duration of the dispatch, represented as a timedelta.\"\"\"\n\n    selector: ComponentSelector\n    \"\"\"The component selector specifying which components the dispatch targets.\"\"\"\n\n    active: bool\n    \"\"\"Indicates whether the dispatch is active and eligible for processing.\"\"\"\n\n    dry_run: bool\n    \"\"\"Indicates if the dispatch is a dry run.\n\n    Executed for logging and monitoring without affecting actual component states.\"\"\"\n\n    payload: dict[str, Any]\n    \"\"\"The dispatch payload containing arbitrary data.\n\n    It is structured as needed for the dispatch operation.\"\"\"\n\n    recurrence: RecurrenceRule\n    \"\"\"The recurrence rule for the dispatch.\n\n    Defining any repeating patterns or schedules.\"\"\"\n\n    create_time: datetime\n    \"\"\"The creation time of the dispatch in UTC. Set when a dispatch is created.\"\"\"\n\n    update_time: datetime\n    \"\"\"The last update time of the dispatch in UTC. Set when a dispatch is modified.\"\"\"\n\n    @classmethod\n    def from_protobuf(cls, pb_object: PBDispatch) -&gt; \"Dispatch\":\n        \"\"\"Convert a protobuf dispatch to a dispatch.\n\n        Args:\n            pb_object: The protobuf dispatch to convert.\n\n        Returns:\n            The converted dispatch.\n        \"\"\"\n        return Dispatch(\n            id=pb_object.id,\n            microgrid_id=pb_object.microgrid_id,\n            type=pb_object.type,\n            create_time=pb_object.create_time.ToDatetime().replace(tzinfo=timezone.utc),\n            update_time=pb_object.update_time.ToDatetime().replace(tzinfo=timezone.utc),\n            start_time=pb_object.start_time.ToDatetime().replace(tzinfo=timezone.utc),\n            duration=timedelta(seconds=pb_object.duration),\n            selector=component_selector_from_protobuf(pb_object.selector),\n            active=pb_object.is_active,\n            dry_run=pb_object.is_dry_run,\n            payload=MessageToDict(pb_object.payload),\n            recurrence=RecurrenceRule.from_protobuf(pb_object.recurrence),\n        )\n\n    def to_protobuf(self) -&gt; PBDispatch:\n        \"\"\"Convert a dispatch to a protobuf dispatch.\n\n        Returns:\n            The converted protobuf dispatch.\n        \"\"\"\n        pb_dispatch = PBDispatch()\n\n        pb_dispatch.id = self.id\n        pb_dispatch.microgrid_id = self.microgrid_id\n        pb_dispatch.type = self.type\n        pb_dispatch.create_time.FromDatetime(self.create_time)\n        pb_dispatch.update_time.FromDatetime(self.update_time)\n        pb_dispatch.start_time.FromDatetime(self.start_time)\n        pb_dispatch.duration = int(self.duration.total_seconds())\n        pb_dispatch.selector.CopyFrom(component_selector_to_protobuf(self.selector))\n        pb_dispatch.is_active = self.active\n        pb_dispatch.is_dry_run = self.dry_run\n        pb_dispatch.payload.update(self.payload)\n        pb_dispatch.recurrence.CopyFrom(self.recurrence.to_protobuf())\n\n        return pb_dispatch\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch.active","title":"active  <code>instance-attribute</code>","text":"<pre><code>active: bool\n</code></pre> <p>Indicates whether the dispatch is active and eligible for processing.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch.create_time","title":"create_time  <code>instance-attribute</code>","text":"<pre><code>create_time: datetime\n</code></pre> <p>The creation time of the dispatch in UTC. Set when a dispatch is created.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch.dry_run","title":"dry_run  <code>instance-attribute</code>","text":"<pre><code>dry_run: bool\n</code></pre> <p>Indicates if the dispatch is a dry run.</p> <p>Executed for logging and monitoring without affecting actual component states.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch.duration","title":"duration  <code>instance-attribute</code>","text":"<pre><code>duration: timedelta\n</code></pre> <p>The duration of the dispatch, represented as a timedelta.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: int\n</code></pre> <p>The unique identifier for the dispatch.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch.microgrid_id","title":"microgrid_id  <code>instance-attribute</code>","text":"<pre><code>microgrid_id: int\n</code></pre> <p>The identifier of the microgrid to which this dispatch belongs.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch.payload","title":"payload  <code>instance-attribute</code>","text":"<pre><code>payload: dict[str, Any]\n</code></pre> <p>The dispatch payload containing arbitrary data.</p> <p>It is structured as needed for the dispatch operation.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch.recurrence","title":"recurrence  <code>instance-attribute</code>","text":"<pre><code>recurrence: RecurrenceRule\n</code></pre> <p>The recurrence rule for the dispatch.</p> <p>Defining any repeating patterns or schedules.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch.selector","title":"selector  <code>instance-attribute</code>","text":"<pre><code>selector: ComponentSelector\n</code></pre> <p>The component selector specifying which components the dispatch targets.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch.start_time","title":"start_time  <code>instance-attribute</code>","text":"<pre><code>start_time: datetime\n</code></pre> <p>The start time of the dispatch in UTC.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: str\n</code></pre> <p>User-defined information about the type of dispatch.</p> <p>This is understood and processed by downstream applications.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch.update_time","title":"update_time  <code>instance-attribute</code>","text":"<pre><code>update_time: datetime\n</code></pre> <p>The last update time of the dispatch in UTC. Set when a dispatch is modified.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch.from_protobuf","title":"from_protobuf  <code>classmethod</code>","text":"<pre><code>from_protobuf(pb_object: Dispatch) -&gt; Dispatch\n</code></pre> <p>Convert a protobuf dispatch to a dispatch.</p> PARAMETER  DESCRIPTION <code>pb_object</code> <p>The protobuf dispatch to convert.</p> <p> TYPE: <code>Dispatch</code> </p> RETURNS DESCRIPTION <code>Dispatch</code> <p>The converted dispatch.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>@classmethod\ndef from_protobuf(cls, pb_object: PBDispatch) -&gt; \"Dispatch\":\n    \"\"\"Convert a protobuf dispatch to a dispatch.\n\n    Args:\n        pb_object: The protobuf dispatch to convert.\n\n    Returns:\n        The converted dispatch.\n    \"\"\"\n    return Dispatch(\n        id=pb_object.id,\n        microgrid_id=pb_object.microgrid_id,\n        type=pb_object.type,\n        create_time=pb_object.create_time.ToDatetime().replace(tzinfo=timezone.utc),\n        update_time=pb_object.update_time.ToDatetime().replace(tzinfo=timezone.utc),\n        start_time=pb_object.start_time.ToDatetime().replace(tzinfo=timezone.utc),\n        duration=timedelta(seconds=pb_object.duration),\n        selector=component_selector_from_protobuf(pb_object.selector),\n        active=pb_object.is_active,\n        dry_run=pb_object.is_dry_run,\n        payload=MessageToDict(pb_object.payload),\n        recurrence=RecurrenceRule.from_protobuf(pb_object.recurrence),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Dispatch.to_protobuf","title":"to_protobuf","text":"<pre><code>to_protobuf() -&gt; Dispatch\n</code></pre> <p>Convert a dispatch to a protobuf dispatch.</p> RETURNS DESCRIPTION <code>Dispatch</code> <p>The converted protobuf dispatch.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>def to_protobuf(self) -&gt; PBDispatch:\n    \"\"\"Convert a dispatch to a protobuf dispatch.\n\n    Returns:\n        The converted protobuf dispatch.\n    \"\"\"\n    pb_dispatch = PBDispatch()\n\n    pb_dispatch.id = self.id\n    pb_dispatch.microgrid_id = self.microgrid_id\n    pb_dispatch.type = self.type\n    pb_dispatch.create_time.FromDatetime(self.create_time)\n    pb_dispatch.update_time.FromDatetime(self.update_time)\n    pb_dispatch.start_time.FromDatetime(self.start_time)\n    pb_dispatch.duration = int(self.duration.total_seconds())\n    pb_dispatch.selector.CopyFrom(component_selector_to_protobuf(self.selector))\n    pb_dispatch.is_active = self.active\n    pb_dispatch.is_dry_run = self.dry_run\n    pb_dispatch.payload.update(self.payload)\n    pb_dispatch.recurrence.CopyFrom(self.recurrence.to_protobuf())\n\n    return pb_dispatch\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.EndCriteria","title":"frequenz.client.dispatch.types.EndCriteria  <code>dataclass</code>","text":"<p>Controls when a recurring dispatch should end.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass EndCriteria:\n    \"\"\"Controls when a recurring dispatch should end.\"\"\"\n\n    count: int | None = None\n    \"\"\"The number of times this dispatch should recur.\"\"\"\n    until: datetime | None = None\n    \"\"\"The end time of this dispatch in UTC.\"\"\"\n\n    @classmethod\n    def from_protobuf(cls, pb_criteria: PBRecurrenceRule.EndCriteria) -&gt; \"EndCriteria\":\n        \"\"\"Convert a protobuf end criteria to an end criteria.\n\n        Args:\n            pb_criteria: The protobuf end criteria to convert.\n\n        Returns:\n            The converted end criteria.\n        \"\"\"\n        instance = cls()\n\n        match pb_criteria.WhichOneof(\"count_or_until\"):\n            case \"count\":\n                instance.count = pb_criteria.count\n            case \"until\":\n                instance.until = pb_criteria.until.ToDatetime().replace(\n                    tzinfo=timezone.utc\n                )\n\n        return instance\n\n    def to_protobuf(self) -&gt; PBRecurrenceRule.EndCriteria:\n        \"\"\"Convert an end criteria to a protobuf end criteria.\n\n        Returns:\n            The converted protobuf end criteria.\n        \"\"\"\n        pb_criteria = PBRecurrenceRule.EndCriteria()\n\n        if self.count is not None:\n            pb_criteria.count = self.count\n        elif self.until is not None:\n            pb_criteria.until.FromDatetime(self.until)\n\n        return pb_criteria\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.EndCriteria-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.EndCriteria.count","title":"count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>count: int | None = None\n</code></pre> <p>The number of times this dispatch should recur.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.EndCriteria.until","title":"until  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>until: datetime | None = None\n</code></pre> <p>The end time of this dispatch in UTC.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.EndCriteria-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.EndCriteria.from_protobuf","title":"from_protobuf  <code>classmethod</code>","text":"<pre><code>from_protobuf(pb_criteria: EndCriteria) -&gt; EndCriteria\n</code></pre> <p>Convert a protobuf end criteria to an end criteria.</p> PARAMETER  DESCRIPTION <code>pb_criteria</code> <p>The protobuf end criteria to convert.</p> <p> TYPE: <code>EndCriteria</code> </p> RETURNS DESCRIPTION <code>EndCriteria</code> <p>The converted end criteria.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>@classmethod\ndef from_protobuf(cls, pb_criteria: PBRecurrenceRule.EndCriteria) -&gt; \"EndCriteria\":\n    \"\"\"Convert a protobuf end criteria to an end criteria.\n\n    Args:\n        pb_criteria: The protobuf end criteria to convert.\n\n    Returns:\n        The converted end criteria.\n    \"\"\"\n    instance = cls()\n\n    match pb_criteria.WhichOneof(\"count_or_until\"):\n        case \"count\":\n            instance.count = pb_criteria.count\n        case \"until\":\n            instance.until = pb_criteria.until.ToDatetime().replace(\n                tzinfo=timezone.utc\n            )\n\n    return instance\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.EndCriteria.to_protobuf","title":"to_protobuf","text":"<pre><code>to_protobuf() -&gt; EndCriteria\n</code></pre> <p>Convert an end criteria to a protobuf end criteria.</p> RETURNS DESCRIPTION <code>EndCriteria</code> <p>The converted protobuf end criteria.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>def to_protobuf(self) -&gt; PBRecurrenceRule.EndCriteria:\n    \"\"\"Convert an end criteria to a protobuf end criteria.\n\n    Returns:\n        The converted protobuf end criteria.\n    \"\"\"\n    pb_criteria = PBRecurrenceRule.EndCriteria()\n\n    if self.count is not None:\n        pb_criteria.count = self.count\n    elif self.until is not None:\n        pb_criteria.until.FromDatetime(self.until)\n\n    return pb_criteria\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Frequency","title":"frequenz.client.dispatch.types.Frequency","text":"<p>             Bases: <code>IntEnum</code></p> <p>Enum representing the frequency of the recurrence.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>class Frequency(IntEnum):\n    \"\"\"Enum representing the frequency of the recurrence.\"\"\"\n\n    UNSPECIFIED = PBRecurrenceRule.FREQUENCY_UNSPECIFIED\n    MINUTELY = PBRecurrenceRule.FREQUENCY_MINUTELY\n    HOURLY = PBRecurrenceRule.FREQUENCY_HOURLY\n    DAILY = PBRecurrenceRule.FREQUENCY_DAILY\n    WEEKLY = PBRecurrenceRule.FREQUENCY_WEEKLY\n    MONTHLY = PBRecurrenceRule.FREQUENCY_MONTHLY\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.RecurrenceRule","title":"frequenz.client.dispatch.types.RecurrenceRule  <code>dataclass</code>","text":"<p>Ruleset governing when and how a dispatch should re-occur.</p> <p>Attributes follow the iCalendar specification (RFC5545) for recurrence rules.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>@dataclass(kw_only=True)\nclass RecurrenceRule:\n    \"\"\"Ruleset governing when and how a dispatch should re-occur.\n\n    Attributes follow the iCalendar specification (RFC5545) for recurrence rules.\n    \"\"\"\n\n    frequency: Frequency = Frequency.UNSPECIFIED\n    \"\"\"The frequency specifier of this recurring dispatch.\"\"\"\n\n    interval: int = 0\n    \"\"\"How often this dispatch should recur, based on the frequency.\"\"\"\n\n    end_criteria: EndCriteria | None = None\n    \"\"\"When this dispatch should end.\n\n    Can recur a fixed number of times or until a given timestamp.\"\"\"\n\n    byminutes: list[int] = field(default_factory=list)\n    \"\"\"On which minute(s) of the hour the event occurs.\"\"\"\n\n    byhours: list[int] = field(default_factory=list)\n    \"\"\"On which hour(s) of the day the event occurs.\"\"\"\n\n    byweekdays: list[Weekday] = field(default_factory=list)\n    \"\"\"On which day(s) of the week the event occurs.\"\"\"\n\n    bymonthdays: list[int] = field(default_factory=list)\n    \"\"\"On which day(s) of the month the event occurs.\"\"\"\n\n    bymonths: list[int] = field(default_factory=list)\n    \"\"\"On which month(s) of the year the event occurs.\"\"\"\n\n    @classmethod\n    def from_protobuf(cls, pb_rule: PBRecurrenceRule) -&gt; \"RecurrenceRule\":\n        \"\"\"Convert a protobuf recurrence rule to a recurrence rule.\n\n        Args:\n            pb_rule: The protobuf recurrence rule to convert.\n\n        Returns:\n            The converted recurrence rule.\n        \"\"\"\n        return RecurrenceRule(\n            frequency=Frequency(pb_rule.freq),\n            interval=pb_rule.interval,\n            end_criteria=(\n                EndCriteria.from_protobuf(pb_rule.end_criteria)\n                if pb_rule.HasField(\"end_criteria\")\n                else None\n            ),\n            byminutes=list(pb_rule.byminutes),\n            byhours=list(pb_rule.byhours),\n            byweekdays=[Weekday(day) for day in pb_rule.byweekdays],\n            bymonthdays=list(pb_rule.bymonthdays),\n            bymonths=list(pb_rule.bymonths),\n        )\n\n    def to_protobuf(self) -&gt; PBRecurrenceRule:\n        \"\"\"Convert a recurrence rule to a protobuf recurrence rule.\n\n        Returns:\n            The converted protobuf recurrence rule.\n        \"\"\"\n        pb_rule = PBRecurrenceRule()\n\n        pb_rule.freq = self.frequency.value\n        pb_rule.interval = self.interval\n        if self.end_criteria is not None:\n            pb_rule.end_criteria.CopyFrom(self.end_criteria.to_protobuf())\n        pb_rule.byminutes.extend(self.byminutes)\n        pb_rule.byhours.extend(self.byhours)\n        pb_rule.byweekdays.extend([day.value for day in self.byweekdays])\n        pb_rule.bymonthdays.extend(self.bymonthdays)\n        pb_rule.bymonths.extend(self.bymonths)\n\n        return pb_rule\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.RecurrenceRule-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.RecurrenceRule.byhours","title":"byhours  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>byhours: list[int] = field(default_factory=list)\n</code></pre> <p>On which hour(s) of the day the event occurs.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.RecurrenceRule.byminutes","title":"byminutes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>byminutes: list[int] = field(default_factory=list)\n</code></pre> <p>On which minute(s) of the hour the event occurs.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.RecurrenceRule.bymonthdays","title":"bymonthdays  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bymonthdays: list[int] = field(default_factory=list)\n</code></pre> <p>On which day(s) of the month the event occurs.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.RecurrenceRule.bymonths","title":"bymonths  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bymonths: list[int] = field(default_factory=list)\n</code></pre> <p>On which month(s) of the year the event occurs.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.RecurrenceRule.byweekdays","title":"byweekdays  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>byweekdays: list[Weekday] = field(default_factory=list)\n</code></pre> <p>On which day(s) of the week the event occurs.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.RecurrenceRule.end_criteria","title":"end_criteria  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>end_criteria: EndCriteria | None = None\n</code></pre> <p>When this dispatch should end.</p> <p>Can recur a fixed number of times or until a given timestamp.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.RecurrenceRule.frequency","title":"frequency  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>frequency: Frequency = UNSPECIFIED\n</code></pre> <p>The frequency specifier of this recurring dispatch.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.RecurrenceRule.interval","title":"interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interval: int = 0\n</code></pre> <p>How often this dispatch should recur, based on the frequency.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.RecurrenceRule-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.RecurrenceRule.from_protobuf","title":"from_protobuf  <code>classmethod</code>","text":"<pre><code>from_protobuf(pb_rule: RecurrenceRule) -&gt; RecurrenceRule\n</code></pre> <p>Convert a protobuf recurrence rule to a recurrence rule.</p> PARAMETER  DESCRIPTION <code>pb_rule</code> <p>The protobuf recurrence rule to convert.</p> <p> TYPE: <code>RecurrenceRule</code> </p> RETURNS DESCRIPTION <code>RecurrenceRule</code> <p>The converted recurrence rule.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>@classmethod\ndef from_protobuf(cls, pb_rule: PBRecurrenceRule) -&gt; \"RecurrenceRule\":\n    \"\"\"Convert a protobuf recurrence rule to a recurrence rule.\n\n    Args:\n        pb_rule: The protobuf recurrence rule to convert.\n\n    Returns:\n        The converted recurrence rule.\n    \"\"\"\n    return RecurrenceRule(\n        frequency=Frequency(pb_rule.freq),\n        interval=pb_rule.interval,\n        end_criteria=(\n            EndCriteria.from_protobuf(pb_rule.end_criteria)\n            if pb_rule.HasField(\"end_criteria\")\n            else None\n        ),\n        byminutes=list(pb_rule.byminutes),\n        byhours=list(pb_rule.byhours),\n        byweekdays=[Weekday(day) for day in pb_rule.byweekdays],\n        bymonthdays=list(pb_rule.bymonthdays),\n        bymonths=list(pb_rule.bymonths),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.RecurrenceRule.to_protobuf","title":"to_protobuf","text":"<pre><code>to_protobuf() -&gt; RecurrenceRule\n</code></pre> <p>Convert a recurrence rule to a protobuf recurrence rule.</p> RETURNS DESCRIPTION <code>RecurrenceRule</code> <p>The converted protobuf recurrence rule.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>def to_protobuf(self) -&gt; PBRecurrenceRule:\n    \"\"\"Convert a recurrence rule to a protobuf recurrence rule.\n\n    Returns:\n        The converted protobuf recurrence rule.\n    \"\"\"\n    pb_rule = PBRecurrenceRule()\n\n    pb_rule.freq = self.frequency.value\n    pb_rule.interval = self.interval\n    if self.end_criteria is not None:\n        pb_rule.end_criteria.CopyFrom(self.end_criteria.to_protobuf())\n    pb_rule.byminutes.extend(self.byminutes)\n    pb_rule.byhours.extend(self.byhours)\n    pb_rule.byweekdays.extend([day.value for day in self.byweekdays])\n    pb_rule.bymonthdays.extend(self.bymonthdays)\n    pb_rule.bymonths.extend(self.bymonths)\n\n    return pb_rule\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.TimeIntervalFilter","title":"frequenz.client.dispatch.types.TimeIntervalFilter  <code>dataclass</code>","text":"<p>Filter for a time interval.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass TimeIntervalFilter:\n    \"\"\"Filter for a time interval.\"\"\"\n\n    start_from: datetime | None\n    \"\"\"Filter by start_time &gt;= start_from.\"\"\"\n\n    start_to: datetime | None\n    \"\"\"Filter by start_time &lt; start_to.\"\"\"\n\n    end_from: datetime | None\n    \"\"\"Filter by end_time &gt;= end_from.\"\"\"\n\n    end_to: datetime | None\n    \"\"\"Filter by end_time &lt; end_to.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.TimeIntervalFilter-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.TimeIntervalFilter.end_from","title":"end_from  <code>instance-attribute</code>","text":"<pre><code>end_from: datetime | None\n</code></pre> <p>Filter by end_time &gt;= end_from.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.TimeIntervalFilter.end_to","title":"end_to  <code>instance-attribute</code>","text":"<pre><code>end_to: datetime | None\n</code></pre> <p>Filter by end_time &lt; end_to.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.TimeIntervalFilter.start_from","title":"start_from  <code>instance-attribute</code>","text":"<pre><code>start_from: datetime | None\n</code></pre> <p>Filter by start_time &gt;= start_from.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.TimeIntervalFilter.start_to","title":"start_to  <code>instance-attribute</code>","text":"<pre><code>start_to: datetime | None\n</code></pre> <p>Filter by start_time &lt; start_to.</p>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.Weekday","title":"frequenz.client.dispatch.types.Weekday","text":"<p>             Bases: <code>IntEnum</code></p> <p>Enum representing the day of the week.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>class Weekday(IntEnum):\n    \"\"\"Enum representing the day of the week.\"\"\"\n\n    UNSPECIFIED = PBRecurrenceRule.WEEKDAY_UNSPECIFIED\n    MONDAY = PBRecurrenceRule.WEEKDAY_MONDAY\n    TUESDAY = PBRecurrenceRule.WEEKDAY_TUESDAY\n    WEDNESDAY = PBRecurrenceRule.WEEKDAY_WEDNESDAY\n    THURSDAY = PBRecurrenceRule.WEEKDAY_THURSDAY\n    FRIDAY = PBRecurrenceRule.WEEKDAY_FRIDAY\n    SATURDAY = PBRecurrenceRule.WEEKDAY_SATURDAY\n    SUNDAY = PBRecurrenceRule.WEEKDAY_SUNDAY\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.component_selector_from_protobuf","title":"frequenz.client.dispatch.types.component_selector_from_protobuf","text":"<pre><code>component_selector_from_protobuf(\n    pb_selector: ComponentSelector,\n) -&gt; ComponentSelector\n</code></pre> <p>Convert a protobuf component selector to a component selector.</p> PARAMETER  DESCRIPTION <code>pb_selector</code> <p>The protobuf component selector to convert.</p> <p> TYPE: <code>ComponentSelector</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the protobuf component selector is invalid.</p> RETURNS DESCRIPTION <code>ComponentSelector</code> <p>The converted component selector.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>def component_selector_from_protobuf(\n    pb_selector: PBComponentSelector,\n) -&gt; ComponentSelector:\n    \"\"\"Convert a protobuf component selector to a component selector.\n\n    Args:\n        pb_selector: The protobuf component selector to convert.\n\n    Raises:\n        ValueError: If the protobuf component selector is invalid.\n\n    Returns:\n        The converted component selector.\n    \"\"\"\n    match pb_selector.WhichOneof(\"selector\"):\n        case \"component_ids\":\n            the_list: list[int] = list(pb_selector.component_ids.component_ids)\n            return the_list\n        case \"component_category\":\n            return ComponentCategory.from_proto(pb_selector.component_category)\n        case _:\n            raise ValueError(\"Invalid component selector\")\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/types/#frequenz.client.dispatch.types.component_selector_to_protobuf","title":"frequenz.client.dispatch.types.component_selector_to_protobuf","text":"<pre><code>component_selector_to_protobuf(\n    selector: ComponentSelector,\n) -&gt; ComponentSelector\n</code></pre> <p>Convert a component selector to a protobuf component selector.</p> PARAMETER  DESCRIPTION <code>selector</code> <p>The component selector to convert.</p> <p> TYPE: <code>ComponentSelector</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the component selector is invalid.</p> RETURNS DESCRIPTION <code>ComponentSelector</code> <p>The converted protobuf component selector.</p> Source code in <code>frequenz/client/dispatch/types.py</code> <pre><code>def component_selector_to_protobuf(\n    selector: ComponentSelector,\n) -&gt; PBComponentSelector:\n    \"\"\"Convert a component selector to a protobuf component selector.\n\n    Args:\n        selector: The component selector to convert.\n\n    Raises:\n        ValueError: If the component selector is invalid.\n\n    Returns:\n        The converted protobuf component selector.\n    \"\"\"\n    pb_selector = PBComponentSelector()\n    match selector:\n        case list():\n            pb_selector.component_ids.component_ids.extend(selector)\n        case ComponentCategory():\n            pb_selector.component_category = selector.to_proto()\n        case _:\n            raise ValueError(\"Invalid component selector\")\n    return pb_selector\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/","title":"Index","text":""},{"location":"reference/frequenz/client/dispatch/test/#frequenz.client.dispatch.test","title":"frequenz.client.dispatch.test","text":"<p>Helpful utilities for testing with the dispatch client.</p>"},{"location":"reference/frequenz/client/dispatch/test/client/","title":"client","text":""},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client","title":"frequenz.client.dispatch.test.client","text":"<p>Fake client for testing.</p>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client-classes","title":"Classes","text":""},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient","title":"frequenz.client.dispatch.test.client.FakeClient","text":"<p>             Bases: <code>Client</code></p> <p>Fake client for testing.</p> <p>This client uses a fake service to simulate the dispatch api.</p> Source code in <code>frequenz/client/dispatch/test/client.py</code> <pre><code>class FakeClient(Client):\n    \"\"\"Fake client for testing.\n\n    This client uses a fake service to simulate the dispatch api.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the mock client.\"\"\"\n        super().__init__(MagicMock(), \"mock\")\n        self._stub = FakeService()  # type: ignore\n\n    @property\n    def dispatches(self) -&gt; list[Dispatch]:\n        \"\"\"List of dispatches.\n\n        Returns:\n            list[Dispatch]: The list of dispatches\n        \"\"\"\n        return self._service.dispatches\n\n    @dispatches.setter\n    def dispatches(self, value: list[Dispatch]) -&gt; None:\n        \"\"\"Set the list of dispatches.\n\n        Args:\n            value: The list of dispatches to set.\n        \"\"\"\n        self._service.dispatches = value\n\n    @property\n    def _service(self) -&gt; FakeService:\n        \"\"\"The fake service.\n\n        Returns:\n            FakeService: The fake service.\n        \"\"\"\n        return cast(FakeService, self._stub)\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient.dispatches","title":"dispatches  <code>property</code> <code>writable</code>","text":"<pre><code>dispatches: list[Dispatch]\n</code></pre> <p>List of dispatches.</p> RETURNS DESCRIPTION <code>list[Dispatch]</code> <p>list[Dispatch]: The list of dispatches</p>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> <p>Initialize the mock client.</p> Source code in <code>frequenz/client/dispatch/test/client.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the mock client.\"\"\"\n    super().__init__(MagicMock(), \"mock\")\n    self._stub = FakeService()  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient.create","title":"create  <code>async</code>","text":"<pre><code>create(\n    microgrid_id: int,\n    _type: str,\n    start_time: datetime,\n    duration: timedelta,\n    selector: ComponentSelector,\n    active: bool = True,\n    dry_run: bool = False,\n    payload: dict[str, Any] | None = None,\n    recurrence: RecurrenceRule | None = None,\n) -&gt; None\n</code></pre> <p>Create a dispatch.</p> PARAMETER  DESCRIPTION <code>microgrid_id</code> <p>The microgrid_id to create the dispatch for.</p> <p> TYPE: <code>int</code> </p> <code>_type</code> <p>User defined string to identify the dispatch type.</p> <p> TYPE: <code>str</code> </p> <code>start_time</code> <p>The start time of the dispatch.</p> <p> TYPE: <code>datetime</code> </p> <code>duration</code> <p>The duration of the dispatch.</p> <p> TYPE: <code>timedelta</code> </p> <code>selector</code> <p>The component selector for the dispatch.</p> <p> TYPE: <code>ComponentSelector</code> </p> <code>active</code> <p>The active status of the dispatch.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>dry_run</code> <p>The dry_run status of the dispatch.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>payload</code> <p>The payload of the dispatch.</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>recurrence</code> <p>The recurrence rule of the dispatch.</p> <p> TYPE: <code>RecurrenceRule | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If start_time is in the past.</p> Source code in <code>frequenz/client/dispatch/_client.py</code> <pre><code>async def create(\n    self,\n    microgrid_id: int,\n    _type: str,\n    start_time: datetime,\n    duration: timedelta,\n    selector: ComponentSelector,\n    active: bool = True,\n    dry_run: bool = False,\n    payload: dict[str, Any] | None = None,\n    recurrence: RecurrenceRule | None = None,\n) -&gt; None:\n    \"\"\"Create a dispatch.\n\n    Args:\n        microgrid_id: The microgrid_id to create the dispatch for.\n        _type: User defined string to identify the dispatch type.\n        start_time: The start time of the dispatch.\n        duration: The duration of the dispatch.\n        selector: The component selector for the dispatch.\n        active: The active status of the dispatch.\n        dry_run: The dry_run status of the dispatch.\n        payload: The payload of the dispatch.\n        recurrence: The recurrence rule of the dispatch.\n\n    Raises:\n        ValueError: If start_time is in the past.\n    \"\"\"\n    if start_time &lt;= datetime.now().astimezone(start_time.tzinfo):\n        raise ValueError(\"start_time must not be in the past\")\n\n    request = DispatchCreateRequest(\n        microgrid_id=microgrid_id,\n        type=_type,\n        start_time=start_time,\n        duration=duration,\n        selector=selector,\n        is_active=active,\n        is_dry_run=dry_run,\n        payload=payload or {},\n        recurrence=recurrence or RecurrenceRule(),\n    ).to_protobuf()\n\n    await self._stub.CreateMicrogridDispatch(request)  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(dispatch_id: int) -&gt; None\n</code></pre> <p>Delete a dispatch.</p> PARAMETER  DESCRIPTION <code>dispatch_id</code> <p>The dispatch_id to delete.</p> <p> TYPE: <code>int</code> </p> Source code in <code>frequenz/client/dispatch/_client.py</code> <pre><code>async def delete(self, dispatch_id: int) -&gt; None:\n    \"\"\"Delete a dispatch.\n\n    Args:\n        dispatch_id: The dispatch_id to delete.\n    \"\"\"\n    request = DispatchDeleteRequest(id=dispatch_id)\n    await self._stub.DeleteMicrogridDispatch(request)  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient.get","title":"get  <code>async</code>","text":"<pre><code>get(dispatch_id: int) -&gt; Dispatch\n</code></pre> <p>Get a dispatch.</p> PARAMETER  DESCRIPTION <code>dispatch_id</code> <p>The dispatch_id to get.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Dispatch</code> <p>The dispatch.</p> <p> TYPE: <code>Dispatch</code> </p> Source code in <code>frequenz/client/dispatch/_client.py</code> <pre><code>async def get(self, dispatch_id: int) -&gt; Dispatch:\n    \"\"\"Get a dispatch.\n\n    Args:\n        dispatch_id: The dispatch_id to get.\n\n    Returns:\n        Dispatch: The dispatch.\n    \"\"\"\n    request = DispatchGetRequest(id=dispatch_id)\n    response = await self._stub.GetMicrogridDispatch(request)  # type: ignore\n    return Dispatch.from_protobuf(response)\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient.list","title":"list  <code>async</code>","text":"<pre><code>list(\n    microgrid_id: int,\n    component_selectors: Iterator[ComponentSelector] = iter(\n        ()\n    ),\n    start_from: datetime | None = None,\n    start_to: datetime | None = None,\n    end_from: datetime | None = None,\n    end_to: datetime | None = None,\n    active: bool | None = None,\n    dry_run: bool | None = None,\n) -&gt; AsyncIterator[Dispatch]\n</code></pre> <p>List dispatches.</p> <p>Example usage:</p> <pre><code>grpc_channel = grpc.aio.insecure_channel(\"example\")\nclient = Client(grpc_channel, \"localhost:50051\")\nasync for dispatch in client.list(microgrid_id=1):\n    print(dispatch)\n</code></pre> YIELDS DESCRIPTION <code>Dispatch</code> <p>The dispatches.</p> <p> TYPE:: <code>AsyncIterator[Dispatch]</code> </p> PARAMETER  DESCRIPTION <code>microgrid_id</code> <p>The microgrid_id to list dispatches for.</p> <p> TYPE: <code>int</code> </p> <code>component_selectors</code> <p>optional, list of component ids or categories to filter by.</p> <p> TYPE: <code>Iterator[ComponentSelector]</code> DEFAULT: <code>iter(())</code> </p> <code>start_from</code> <p>optional, filter by start_time &gt;= start_from.</p> <p> TYPE: <code>datetime | None</code> DEFAULT: <code>None</code> </p> <code>start_to</code> <p>optional, filter by start_time &lt; start_to.</p> <p> TYPE: <code>datetime | None</code> DEFAULT: <code>None</code> </p> <code>end_from</code> <p>optional, filter by end_time &gt;= end_from.</p> <p> TYPE: <code>datetime | None</code> DEFAULT: <code>None</code> </p> <code>end_to</code> <p>optional, filter by end_time &lt; end_to.</p> <p> TYPE: <code>datetime | None</code> DEFAULT: <code>None</code> </p> <code>active</code> <p>optional, filter by active status.</p> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> <code>dry_run</code> <p>optional, filter by dry_run status.</p> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>AsyncIterator[Dispatch]</code> <p>An async iterator of dispatches.</p> Source code in <code>frequenz/client/dispatch/_client.py</code> <pre><code>async def list(\n    self,\n    microgrid_id: int,\n    component_selectors: Iterator[ComponentSelector] = iter(()),\n    start_from: datetime | None = None,\n    start_to: datetime | None = None,\n    end_from: datetime | None = None,\n    end_to: datetime | None = None,\n    active: bool | None = None,\n    dry_run: bool | None = None,\n) -&gt; AsyncIterator[Dispatch]:\n    \"\"\"List dispatches.\n\n    Example usage:\n\n    ```python\n    grpc_channel = grpc.aio.insecure_channel(\"example\")\n    client = Client(grpc_channel, \"localhost:50051\")\n    async for dispatch in client.list(microgrid_id=1):\n        print(dispatch)\n    ```\n\n    Yields:\n        Dispatch: The dispatches.\n\n    Args:\n        microgrid_id: The microgrid_id to list dispatches for.\n        component_selectors: optional, list of component ids or categories to filter by.\n        start_from: optional, filter by start_time &gt;= start_from.\n        start_to: optional, filter by start_time &lt; start_to.\n        end_from: optional, filter by end_time &gt;= end_from.\n        end_to: optional, filter by end_time &lt; end_to.\n        active: optional, filter by active status.\n        dry_run: optional, filter by dry_run status.\n\n    Returns:\n        An async iterator of dispatches.\n    \"\"\"\n    time_interval = None\n\n    def to_timestamp(dt: datetime | None) -&gt; Timestamp | None:\n        if dt is None:\n            return None\n\n        ts = Timestamp()\n        ts.FromDatetime(dt)\n        return ts\n\n    if start_from or start_to or end_from or end_to:\n        time_interval = PBTimeIntervalFilter(\n            start_from=to_timestamp(start_from),\n            start_to=to_timestamp(start_to),\n            end_from=to_timestamp(end_from),\n            end_to=to_timestamp(end_to),\n        )\n\n    selectors = []\n\n    for selector in component_selectors:\n        selectors.append(component_selector_to_protobuf(selector))\n\n    filters = DispatchFilter(\n        selectors=selectors,\n        time_interval=time_interval,\n        is_active=active,\n        is_dry_run=dry_run,\n    )\n    request = DispatchListRequest(microgrid_id=microgrid_id, filter=filters)\n\n    response = await self._stub.ListMicrogridDispatches(request)  # type: ignore\n    for dispatch in response.dispatches:\n        yield Dispatch.from_protobuf(dispatch)\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.FakeClient.update","title":"update  <code>async</code>","text":"<pre><code>update(\n    *, dispatch_id: int, new_fields: dict[str, Any]\n) -&gt; None\n</code></pre> <p>Update a dispatch.</p> <p>The <code>new_fields</code> argument is a dictionary of fields to update. The keys are the field names, and the values are the new values for the fields.</p> <p>For recurrence fields, the keys are preceeded by \"recurrence.\".</p> PARAMETER  DESCRIPTION <code>dispatch_id</code> <p>The dispatch_id to update.</p> <p> TYPE: <code>int</code> </p> <code>new_fields</code> <p>The fields to update.</p> <p> TYPE: <code>dict[str, Any]</code> </p> Source code in <code>frequenz/client/dispatch/_client.py</code> <pre><code>async def update(\n    self,\n    *,\n    dispatch_id: int,\n    new_fields: dict[str, Any],\n) -&gt; None:\n    \"\"\"Update a dispatch.\n\n    The `new_fields` argument is a dictionary of fields to update. The keys are\n    the field names, and the values are the new values for the fields.\n\n    For recurrence fields, the keys are preceeded by \"recurrence.\".\n\n    Args:\n        dispatch_id: The dispatch_id to update.\n        new_fields: The fields to update.\n    \"\"\"\n    msg = DispatchUpdateRequest(id=dispatch_id)\n\n    for key, val in new_fields.items():\n        path = key.split(\".\")\n\n        match path[0]:\n            case \"type\":\n                msg.update.type = val\n            case \"start_time\":\n                msg.update.start_time.FromDatetime(val)\n            case \"duration\":\n                msg.update.duration = int(val.total_seconds())\n            case \"selector\":\n                msg.update.selector.CopyFrom(component_selector_to_protobuf(val))\n            case \"is_active\":\n                msg.update.is_active = val\n            case \"active\":\n                msg.update.is_active = val\n                key = \"is_active\"\n            case \"is_dry_run\":\n                msg.update.is_dry_run = val\n            case \"dry_run\":\n                msg.update.is_dry_run = val\n                key = \"is_dry_run\"\n            case \"recurrence\":\n                match path[1]:\n                    case \"freq\":\n                        msg.update.recurrence.freq = val\n                    # Proto uses \"freq\" instead of \"frequency\"\n                    case \"frequency\":\n                        msg.update.recurrence.freq = val\n                        # Correct the key to \"recurrence.freq\"\n                        key = \"recurrence.freq\"\n                    case \"interval\":\n                        msg.update.recurrence.interval = val\n                    case \"end_criteria\":\n                        msg.update.recurrence.end_criteria.CopyFrom(\n                            val.to_protobuf()\n                        )\n                    case \"byminutes\":\n                        msg.update.recurrence.byminutes.extend(val)\n                    case \"byhours\":\n                        msg.update.recurrence.byhours.extend(val)\n                    case \"byweekdays\":\n                        msg.update.recurrence.byweekdays.extend(val)\n                    case \"bymonthdays\":\n                        msg.update.recurrence.bymonthdays.extend(val)\n                    case \"bymonths\":\n                        msg.update.recurrence.bymonths.extend(val)\n\n        msg.update_mask.paths.append(key)\n\n    await self._stub.UpdateMicrogridDispatch(msg)  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/dispatch/test/client/#frequenz.client.dispatch.test.client.to_create_params","title":"frequenz.client.dispatch.test.client.to_create_params","text":"<pre><code>to_create_params(dispatch: Dispatch) -&gt; dict[str, Any]\n</code></pre> <p>Convert a dispatch to client.create parameters.</p> PARAMETER  DESCRIPTION <code>dispatch</code> <p>The dispatch to convert.</p> <p> TYPE: <code>Dispatch</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>dict[str, Any]: The create parameters.</p> Source code in <code>frequenz/client/dispatch/test/client.py</code> <pre><code>def to_create_params(dispatch: Dispatch) -&gt; dict[str, Any]:\n    \"\"\"Convert a dispatch to client.create parameters.\n\n    Args:\n        dispatch: The dispatch to convert.\n\n    Returns:\n        dict[str, Any]: The create parameters.\n    \"\"\"\n    return {\n        \"microgrid_id\": dispatch.microgrid_id,\n        \"_type\": dispatch.type,\n        \"start_time\": dispatch.start_time,\n        \"duration\": dispatch.duration,\n        \"selector\": dispatch.selector,\n        \"active\": dispatch.active,\n        \"dry_run\": dispatch.dry_run,\n        \"payload\": dispatch.payload,\n        \"recurrence\": dispatch.recurrence,\n    }\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/generator/","title":"generator","text":""},{"location":"reference/frequenz/client/dispatch/test/generator/#frequenz.client.dispatch.test.generator","title":"frequenz.client.dispatch.test.generator","text":"<p>A sampler for dispatch messages.</p>"},{"location":"reference/frequenz/client/dispatch/test/generator/#frequenz.client.dispatch.test.generator-classes","title":"Classes","text":""},{"location":"reference/frequenz/client/dispatch/test/generator/#frequenz.client.dispatch.test.generator.DispatchGenerator","title":"frequenz.client.dispatch.test.generator.DispatchGenerator","text":"<p>Generates random dispatch messages.</p> Source code in <code>frequenz/client/dispatch/test/generator.py</code> <pre><code>class DispatchGenerator:\n    \"\"\"Generates random dispatch messages.\"\"\"\n\n    def __init__(self, seed: int = 0) -&gt; None:\n        \"\"\"Initialize the sampler.\n\n        Args:\n            seed: seed to initialize the rng with\n        \"\"\"\n        self._rng = random.Random(seed)\n        self._last_id: int = 0\n\n    def generate_recurrence_rule(self) -&gt; RecurrenceRule:\n        \"\"\"Generate a random recurrence rule.\n\n        Returns:\n            a random recurrence rule\n        \"\"\"\n        return RecurrenceRule(\n            frequency=self._rng.choice(list(Frequency)[1:]),\n            interval=self._rng.randint(1, 100),\n            end_criteria=self._rng.choice(\n                [\n                    None,\n                    self._rng.choice(\n                        [\n                            EndCriteria(count=self._rng.randint(1, 1000)),\n                            EndCriteria(\n                                until=datetime.fromtimestamp(\n                                    self._rng.randint(0, 1000000),\n                                    tz=timezone.utc,\n                                )\n                            ),\n                        ]\n                    ),\n                ]\n            ),\n            byminutes=[\n                self._rng.randint(0, 59) for _ in range(self._rng.randint(0, 10))\n            ],\n            byhours=[self._rng.randint(0, 23) for _ in range(self._rng.randint(0, 10))],\n            byweekdays=[\n                self._rng.choice(list(Weekday)[1:])\n                for _ in range(self._rng.randint(0, 7))\n            ],\n            bymonthdays=[\n                self._rng.randint(1, 31) for _ in range(self._rng.randint(0, 10))\n            ],\n            bymonths=[\n                self._rng.randint(1, 12) for _ in range(self._rng.randint(0, 12))\n            ],\n        )\n\n    def generate_dispatch(self, microgrid_id: int | None = None) -&gt; Dispatch:\n        \"\"\"Generate a random dispatch instance.\n\n        Args:\n            microgrid_id: The microgrid_id to set on the dispatch.\n\n        Returns:\n            a random dispatch instance\n        \"\"\"\n        self._last_id += 1\n        create_time = datetime.fromtimestamp(\n            self._rng.randint(0, 1000000), tz=timezone.utc\n        )\n\n        return Dispatch(\n            id=self._last_id,\n            create_time=create_time,\n            update_time=create_time + timedelta(seconds=self._rng.randint(0, 1000000)),\n            microgrid_id=microgrid_id or self._rng.randint(0, 100),\n            type=str(self._rng.randint(0, 100_000)),\n            start_time=datetime.now().astimezone(timezone.utc)\n            + timedelta(seconds=self._rng.randint(0, 1000000)),\n            duration=timedelta(seconds=self._rng.randint(0, 1000000)),\n            selector=self._rng.choice(  # type: ignore\n                [\n                    self._rng.choice(list(ComponentCategory)[1:]),\n                    [\n                        self._rng.randint(1, 100)\n                        for _ in range(self._rng.randint(1, 10))\n                    ],\n                ]\n            ),\n            active=self._rng.choice([True, False]),\n            dry_run=self._rng.choice([True, False]),\n            payload={\n                f\"key_{i}\": self._rng.choice(\n                    [\n                        self._rng.randint(0, 100),\n                        self._rng.uniform(0, 100),\n                        self._rng.choice([True, False]),\n                        self._rng.choice([\"a\", \"b\", \"c\"]),\n                    ]\n                )\n                for i in range(self._rng.randint(0, 10))\n            },\n            recurrence=self.generate_recurrence_rule(),\n        )\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/generator/#frequenz.client.dispatch.test.generator.DispatchGenerator-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/dispatch/test/generator/#frequenz.client.dispatch.test.generator.DispatchGenerator.__init__","title":"__init__","text":"<pre><code>__init__(seed: int = 0) -&gt; None\n</code></pre> <p>Initialize the sampler.</p> PARAMETER  DESCRIPTION <code>seed</code> <p>seed to initialize the rng with</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/client/dispatch/test/generator.py</code> <pre><code>def __init__(self, seed: int = 0) -&gt; None:\n    \"\"\"Initialize the sampler.\n\n    Args:\n        seed: seed to initialize the rng with\n    \"\"\"\n    self._rng = random.Random(seed)\n    self._last_id: int = 0\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/generator/#frequenz.client.dispatch.test.generator.DispatchGenerator.generate_dispatch","title":"generate_dispatch","text":"<pre><code>generate_dispatch(\n    microgrid_id: int | None = None,\n) -&gt; Dispatch\n</code></pre> <p>Generate a random dispatch instance.</p> PARAMETER  DESCRIPTION <code>microgrid_id</code> <p>The microgrid_id to set on the dispatch.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Dispatch</code> <p>a random dispatch instance</p> Source code in <code>frequenz/client/dispatch/test/generator.py</code> <pre><code>def generate_dispatch(self, microgrid_id: int | None = None) -&gt; Dispatch:\n    \"\"\"Generate a random dispatch instance.\n\n    Args:\n        microgrid_id: The microgrid_id to set on the dispatch.\n\n    Returns:\n        a random dispatch instance\n    \"\"\"\n    self._last_id += 1\n    create_time = datetime.fromtimestamp(\n        self._rng.randint(0, 1000000), tz=timezone.utc\n    )\n\n    return Dispatch(\n        id=self._last_id,\n        create_time=create_time,\n        update_time=create_time + timedelta(seconds=self._rng.randint(0, 1000000)),\n        microgrid_id=microgrid_id or self._rng.randint(0, 100),\n        type=str(self._rng.randint(0, 100_000)),\n        start_time=datetime.now().astimezone(timezone.utc)\n        + timedelta(seconds=self._rng.randint(0, 1000000)),\n        duration=timedelta(seconds=self._rng.randint(0, 1000000)),\n        selector=self._rng.choice(  # type: ignore\n            [\n                self._rng.choice(list(ComponentCategory)[1:]),\n                [\n                    self._rng.randint(1, 100)\n                    for _ in range(self._rng.randint(1, 10))\n                ],\n            ]\n        ),\n        active=self._rng.choice([True, False]),\n        dry_run=self._rng.choice([True, False]),\n        payload={\n            f\"key_{i}\": self._rng.choice(\n                [\n                    self._rng.randint(0, 100),\n                    self._rng.uniform(0, 100),\n                    self._rng.choice([True, False]),\n                    self._rng.choice([\"a\", \"b\", \"c\"]),\n                ]\n            )\n            for i in range(self._rng.randint(0, 10))\n        },\n        recurrence=self.generate_recurrence_rule(),\n    )\n</code></pre>"},{"location":"reference/frequenz/client/dispatch/test/generator/#frequenz.client.dispatch.test.generator.DispatchGenerator.generate_recurrence_rule","title":"generate_recurrence_rule","text":"<pre><code>generate_recurrence_rule() -&gt; RecurrenceRule\n</code></pre> <p>Generate a random recurrence rule.</p> RETURNS DESCRIPTION <code>RecurrenceRule</code> <p>a random recurrence rule</p> Source code in <code>frequenz/client/dispatch/test/generator.py</code> <pre><code>def generate_recurrence_rule(self) -&gt; RecurrenceRule:\n    \"\"\"Generate a random recurrence rule.\n\n    Returns:\n        a random recurrence rule\n    \"\"\"\n    return RecurrenceRule(\n        frequency=self._rng.choice(list(Frequency)[1:]),\n        interval=self._rng.randint(1, 100),\n        end_criteria=self._rng.choice(\n            [\n                None,\n                self._rng.choice(\n                    [\n                        EndCriteria(count=self._rng.randint(1, 1000)),\n                        EndCriteria(\n                            until=datetime.fromtimestamp(\n                                self._rng.randint(0, 1000000),\n                                tz=timezone.utc,\n                            )\n                        ),\n                    ]\n                ),\n            ]\n        ),\n        byminutes=[\n            self._rng.randint(0, 59) for _ in range(self._rng.randint(0, 10))\n        ],\n        byhours=[self._rng.randint(0, 23) for _ in range(self._rng.randint(0, 10))],\n        byweekdays=[\n            self._rng.choice(list(Weekday)[1:])\n            for _ in range(self._rng.randint(0, 7))\n        ],\n        bymonthdays=[\n            self._rng.randint(1, 31) for _ in range(self._rng.randint(0, 10))\n        ],\n        bymonths=[\n            self._rng.randint(1, 12) for _ in range(self._rng.randint(0, 12))\n        ],\n    )\n</code></pre>"}]}